/* (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. */

/**
 * This class is the base certification decision dialog. Components
 * which generate a DecisionDialog expect a 'finish' event to fire
 * which should return a SailPoint.Decision object.
 */
Ext.define('SailPoint.certification.BaseDecisionDialog', {
	extend : 'Ext.Window',

    decision : null,

    /**
     * The item being updated by this decision. Note this
     * will only be non-null if the decision is NOT a
     * bulk decision.
     */
    certificationItem : null,

    certificationConfig : null,

	isReadOnly: false,

    initComponent : function() {

        this.addEvents(
            /**
             * @event finish
             * Fired when the dialog is completed.
             * @param {SailPoint.Decision} updatedDecision - Decision object, updated by user input from the dialog
             */
             'finish',

             /**
              * @event initComplete
              * Fired when the dialog initialization has completed. This tells the dialog that it
              * can remove it's mask and begin accepting input.
              */
              'initComplete',

              /**
               * @event readyForDisplay
               * Indicates that the dialog is ready to be displayed
               */
              'readyForDisplay'
        );

        // Hide the mask that we rendered while initializing
        this.on('initComplete', function(){
            this.hideMask();
        }, this);

        // Hide the mask that we rendered while initializing
        this.on('readyForDisplay', function(){
            this.readyForDisplay();
        }, this);

        Ext.applyIf(this, {
            width:750,
            height:320
        });

        Ext.apply(this, {
            layout:'fit',
            modal:true,
            closable:false
        });

       this.callParent(arguments);
    },


    //---------------------------------------------------------------
    //
    // EXTENSIONS POINTS - insert your customizations in these methods
    //
    //---------------------------------------------------------------

    handleError : function(exception, msg){
        SailPoint.FATAL_ERR_JAVASCRIPT(exception, msg);
        this.cancel();
    },

    validateForm : function(){
        return true;
    },

    /**
     * This is called right before the dialog is displayed. This
     * should reset the dialog state to it's default state.
     */
    reset : function(){

	},

    /**
     * This is called right before the dialog is displayed but after
     * it has been reset. This should pre-populate any form fields.
     * If you need to call out to the server for more info, do it here.
     *
     * NOTE: Remember to fire initComplete when you're done init'ing
     */
    init : function(){
        this.fireEvent('initComplete');
	},

    /**
     * This gives subclasses a hook where they can perform
     * extra initialization, such as determining if the
     * dialog needs to be displayed at all. Once the
     * dialog is ready, the 'readyForDisplay' event should
     * be fired. You can opt to not display the dialog by
     * not firing the event.
     */
    verifyDialogIsReady : function(){
        this.fireEvent('readyForDisplay');
    },

    /**
     * Returns the decision generated by this dialog. Subclasses
     * should copy data from forms or update the decision in
     * any way necessary.
     */
    getDecision : function(){
        return this.decision;
    },

    /**
     * Determines what happens when the user clicks cancel.
     */
    getCancelDecision : function(){
        this.decision.status = SailPoint.Decision.STATUS_CANCEL;

        if (this.decision.requiresDelegationReview == true){
               this.decision.delegationReview = false;
        }

        return this.decision;
    },

    createDelegationReviewDecision : function(decisionValue){
        var delegationReviewDecision = new SailPoint.Decision();
        delegationReviewDecision.id = 'reviewDelegation-' + this.decision.id;
        delegationReviewDecision.selectionCriteria = this.decision.selectionCriteria.clone();
        delegationReviewDecision.status = decisionValue;
        delegationReviewDecision.workItemId = this.decision.workItemId;
        delegationReviewDecision.delegationReview = true;
        return delegationReviewDecision;
    },

    acceptDelegationReview : function(){
        this.decision = this.createDelegationReviewDecision(SailPoint.Decision.STATUS_DELEGATION_REVIEW_ACCEPT);
        this.decision.dialogState.push("DelegationReviewDialog");
        this.save();
    },

    rejectDelegationReview : function(){
        this.decision = this.createDelegationReviewDecision(SailPoint.Decision.STATUS_DELEGATION_REVIEW_REJECT);
        this.decision.dialogState.push("DelegationReviewDialog");
        this.save();
    },

    //---------------------------------------------------------------
    //
    // BASE METHODS - These should most likely not be modified or extended
    //
    //---------------------------------------------------------------

    baseInit : function(){
        if (this.decision && this.decision.requiresDelegationReview){
            this.isReadOnly = true;
        }
    },

    // Utility method to hide  a field. Ext doesnt make this easy...
    hideField : function(component){

        if (!component || !component.container)
            return;

        var elem = component.container.up('div.x-form-item');
        if (elem){
            elem.enableDisplayMode(Element.DISPLAY);
            elem.hide();
        } else {
            component.hide();
        }

    },

    // Utility method to show a field. Ext doesnt make this easy...
    showField : function(component){

        if (!component || !component.container)
            return;

        // Using .show() doesnt seem to work event setting the display mode
        var elem = component.container.up('div.x-form-item');
        if (elem && elem.dom)
            elem.dom.style["display"] = '';
        component.show();
    },

    display: function (decision, certificationItem, certificationConfig){

        var readOnly = decision.readOnly == true ? true : (certificationItem ? !certificationItem.isEditable() : false);

        if (decision.requiresDelegationReview == true && !decision.delegationReview)
            readOnly = false;

        // Bulk decisions are always editable
        this.isReadOnly = readOnly;
        this.decision = decision;
        this.certificationItem = certificationItem;
        this.certificationConfig = certificationConfig;

        this.verifyDialogIsReady();
    },

    readyForDisplay : function(){
        this.reset();
        this.show();
        this.showMask();
        this.init();
    },

    /**
     * Called when the dialog is completed by the user. Note that
     * this method does not handle the cancel button click.
     */
    save: function() {

        if (this.decision.isDelegationReviewDecision()){
            if (this.fireEvent('finish', this.decision)){
                this.close();
                return true;
            }
        } else if (!this.isReadOnly || this.decision.showChallengeDialog == true || this.decision.showRemediationDetails){
            try{
                var updatedDecision = this.getDecision();
                // The finish event returns control to SailPoint.Decider.processDecision() and
                // passes back the updated decision
                if (this.validate() && this.fireEvent('finish', updatedDecision)){
                    this.close();
                    return true;
                }
            } catch(err){
                SailPoint.FATAL_ERR_JAVASCRIPT(err, "Error saving decision. ");
            }
        } else {
            this.close();
        }
        return false;
    },

    /**
     * Called when the cancel button is clicked
     */
    cancel : function() {

        // if we're in readonly mode, there's not need to pass back the decision.
        if (!this.isReadOnly || this.decision.showChallengeDialog == true || this.decision.showRemediationDetails){
            var updatedDecision = this.getCancelDecision();
            // The finish event returns control to SailPoint.Decider.processDecision() and
            // passes back the updated decision
            this.fireEvent('finish', updatedDecision);
        }
        this.close();
    },

    close: function() {
        // Sometimes we may close the dialog before it's
        // been displayed. Check to make sure that we have
        // an element before hiding, otherwise we will get an
        // exception thrown by EXT
        if (this.el){
            this.hide();
        }
    },

    validate : function(){
        if (this.isReadOnly)
            return true;

        return this.validateForm();
    },

    showMask:function(){
		this.getEl().mask(Ext.LoadMask.prototype.msg, 'x-mask-loading');
	},

	hideMask:function(){
		this.getEl().unmask();
	},
     //---------------------------------------------------------------
    //
    // UTILITY METHODS
    //
    //---------------------------------------------------------------

    formatIdentityName : function(identity){

        if (identity){
            if (identity.displayName && identity.displayName != ''){
                return identity.displayName;
            }else if (identity.name && identity.name != ''){
                return identity.name;
            }
        }

        return "";
    }
});

/**
  * Used by the Decider to either create a new instance or re-use an
  * existing one.
 */
SailPoint.certification.BaseDecisionDialog.baseGetInstance = function(dialogClass, options){

    var dialogId = options.id;

    if (!dialogId){
        alert("Dialog ID not specified while building decision dialog.");
        return;
    }

    var dialog = Ext.getCmp(dialogId);

    if (!dialog){
        dialog = new dialogClass(options);
    }

    return dialog;
}
