<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">

<!-- (c) Copyright 2010 SailPoint Technologies, Inc., All Rights Reserved. -->

<!--
  A library of workflow subprocesses.
  These are common to both IIQ and LCM.
-->
<sailpoint>

<!-- **********************************************************************

  Do Provisioning Forms

  Enter into a loop presenting and assimilating provisioning forms until
  the provisioning project runs out of questions to ask.

********************************************************************** -->

<Workflow name='Do Provisioning Forms'
          type='Subprocess'
          libraries='Identity'>

  <!--
    Input variables
  -->

  <Variable name='identityName' input='true' required='true'>
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>

  <Variable name="identityDisplayName" input='true'
            initializer='script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)'>
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>

  <Variable name='project' input='true' output='true' required='true'>
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
      This may include a list of Question objects which will 
      cause the generation of a Form and a WorkItem to solicit
      additional information necessary for provisioning.
    </Description>
  </Variable>

  <!-- Consider passing this in the project? -->
  <Variable name='formTemplate' input='true' required='true'>
    <Description>
      The name of the Form object that will be the template for
      generated forms.
    </Description>
  </Variable>

  <Variable name='preferredOwner' input='true'>
    <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, a form for
      one of the other identities is generated at random.  When set the
      value is usually the same as "sessionOwner" a built-in system variable
      containing the name of the user currently interacting with a 
      workflow session.
    </Description>
  </Variable>
  
  <Variable name='priority' input='true'>
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of any generated workitems.
    </Description>
  </Variable>
  
  <Variable name='requiredOwner' input='true'>
    <Description>
      Optional argument to buildProvisioningForm to pass in the name of
      an identity we should we should try to process first when feeding
      forms back to the workflow.  If there are no questions for that
      identity and there are questions for other identities, no form is 
      returned and the workflow may terminate without answering all of the
      questions in the project.

      This variable should only be on if you want to....
      jsl - I forget why we have this, something to do with form fill
      on both sides of an approval?
    </Description>
  </Variable>

  <Variable name='fallbackOwner' input='true'>
    <Description>
      Optional argument to specify a fallback identity to own Forms when nothing else is specified.
    </Description>
  </Variable>

  <Variable name='accountSelectionOwner' input='true'>
    <Description>
      Optional argument to buildAccountSelectionForm to specify identity that owns the Form.
    </Description>
  </Variable>
  
  <Variable name='disableManualAccountSelection' input='true' >
    <Description>
      When set to 'true' the system will not send out Account Selection Notification emails 
      for users with more than one account on any one application and the system 
      can't determine the provisioning account.
      This is only passed in from Identity Refresh workflow.
    </Description>
  </Variable>
  
  <!--
    Internal variables
  -->

  <Variable name='workItemForm'>
    <Description>
      Holds the assembled provisioning form for this user. This is generated
      dynamically and passed into a work item for presentation.  
      During rendering the new field values are saved in the form fields.  
      When the work item is assimilated, we copy the form from the work
      item back to this variable for further processing.
      
      Note that this must be named workItemForm if you want to use it
      in the "send" list of an Approval.  This is the name recognized
      by WorkItemFormBean.  If you need to use a different name, or
      have multiple forms then you will need to use an Arg in the Approval
      to do the name translation.
    </Description>
  </Variable>

  <Variable name='formOwnerError'>
    <Description>
      Set to true if we ever have difficulty determining a form owner.
      Used to break out of the provisioning loop.  This really shouldn't
      be necessary but be safe.
    </Description>
  </Variable>

  <Variable name='workItemComments'>
    <Description>
     Global comments list which should be appended to the comments list ofr
     each approval.
    </Description>
  </Variable>

  <Variable name='accountSelectionForm'>
    <Description>
      Dynamic account selection form generated when target account is ambiguous.
    </Description>
  </Variable>
  
  <Variable name='calculatedAccountSelectionOwner'>
    <Description>
      Calculated owner value for account selection form.
    </Description>
  </Variable>

  <!--
    Steps
  -->

  <!-- START -->
  <Step icon="Start" name="start" posX="33" posY="16">
    <Transition to='Get Account Selection Owner'/>
  </Step>

  <!-- Calculate account selection owner -->
  <Step condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; (project.hasUnansweredProvisioningTargets() || project.hasUnansweredAccountSelections())"
        action="call:getAccountSelectionOwner" 
        resultVariable="calculatedAccountSelectionOwner"
        name="Get Account Selection Owner" posX="372" posY="12">
    <Arg name='accountSelectionOwner' value='ref:accountSelectionOwner'/>
    <Arg name='owner' value='ref:requiredOwner'/>
    <Arg name='preferredOwner' value='ref:preferredOwner'/>
    <Arg name='fallbackOwner' value='ref:fallbackOwner'/>
    <Transition to='Build Account Selection Form'/>
  </Step>

  <!-- Build account selection owner form using owner from previous step -->
  <Step condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredProvisioningTargets()" 
        action="call:buildAccountSelectionForm" 
        resultVariable="accountSelectionForm" 
        name="Build Account Selection Form" posX="561" posY="12">
    <Description>
      Call the standard handler method to build the account selection form.
    </Description>
    <Arg name='project' value='ref:project'/>
    <Arg name='owner' value='ref:calculatedAccountSelectionOwner'/>
    <Transition to='Present Account Selection Form'/>
  </Step>

  <!-- Present the account selection owner form -->
  <Step condition="script:!isNull(accountSelectionForm)" name="Present Account Selection Form" posX="561" posY="12">
    <Description>
      Present the account selection form and check to make sure all account selections were made.
    </Description>
    <Approval send='identityName,identityDisplayName,launcher' owner="script:accountSelectionForm.getTargetUser()">
      
      <!-- Work item parameters. -->
      <Arg name='workItemType' value='Form'/>
      <Arg name='workItemDescription' value='Role Account Selection for $(identityDisplayName)'/>
      <Arg name='workItemForm' value='ref:accountSelectionForm'/>
      
      <Arg name='workItemDisableNotification'>
        <Script>
          <Source>
           <![CDATA[
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) && !sessionOwner.equals("System") && !sessionOwner.equals("Scheduler");
            ]]>
          </Source>
        </Script>
      </Arg>
      <Arg name='workItemPriority' value='ref:priority'/>

      <WorkItemConfig>
        <NotificationEmailTemplateRef>
          <Reference class='EmailTemplate' name='Account Selection Notification'/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
      
      <AfterScript>
        <Source>
          import sailpoint.object.Form;
          import sailpoint.object.ProvisioningTarget;
          import sailpoint.object.AccountSelection;
          import sailpoint.object.Field;

          Form accountSelectionForm = item.getForm();
          
          Iterator fieldIterator = accountSelectionForm.iterateFields();

          List targets = project.getProvisioningTargets();
          
          //apply selected value to matching AccountSelection
          //if accountSelectionId, then apply to the first unanswered AccountSelection
          while (fieldIterator.hasNext()) {
              Field fld = (Field)fieldIterator.next();
              if (fld == null) 
                continue;

              Integer targetIndex = (Integer)fld.getAttribute("targetIndex");
              Integer selectionIndex = (Integer)fld.getAttribute("selectionIndex");
              
              if (targetIndex == null || selectionIndex == null) continue;
                            
              ProvisioningTarget target = (ProvisioningTarget) targets.get(targetIndex.intValue());
              
              List selections = target.getAccountSelections();
              AccountSelection selection = (AccountSelection) selections.get(selectionIndex.intValue()); 
                 
              if (selection.isAnswered()) continue;
              
              if (fld.getValue().equals("doCreateOpt")) {
                selection.setDoCreate(true);
              }
              else {
                selection.setSelection(fld.getValue());
              }
          }
          
        </Source> 
      </AfterScript>
      
    </Approval>
    <Transition to='Handle Old Account Selections'/>
  </Step>

  <Step condition="script:project != null &amp;&amp; !isTrue(disableManualAccountSelection) &amp;&amp; project.hasUnansweredAccountSelections()" 
        name="Handle Old Account Selections" posX="561" posY="12">
    <Description>
      There are two ways to model account selections.  Pre 6.3 workflows use a 
      top-level List of AccountSelection objects on the project.  6.3 added a List
      of ProvisioningTarget objects.  We need to handle both, but there will never
      be a combination of them in the same workflow case.  This step handles
      the old model.
    </Description>

    <Approval renderer='accountSelectionRenderer.xhtml'  owner="ref:calculatedAccountSelectionOwner">
      <!-- Work item parameters. -->
      <Arg name='workItemRequester' value='$(launcher)'/>
      <Arg name='workItemDescription' value='Account Selection for User: $(identityDisplayName)'/>
      <Arg name='workItemDisableNotification'>
        <Script>
          <Source>
           <![CDATA[
            // If this is interactive then don't bother sending email notifications.
            return (null != sessionOwner) && !sessionOwner.equals("System") && !sessionOwner.equals("Scheduler");
            ]]>
          </Source>
        </Script>
      </Arg>
      <Arg name='workItemPriority' value='ref:priority'/>
      <!-- Attributes for the work item. -->
      <Arg name='accounts' value='script:project.getAccountSelections()'/>
      <Arg name='expansionItems' value='script:project.getExpansionItems()'/>
      <Arg name="identityDisplayName" value="$(identityDisplayName)" />
      <Arg name="identityName" value="$(identityName)" />

      <!-- Return the accounts into the approval to be used in the after script. -->
      <Return name='accounts' to='accountSelectionsFromWorkItem' local='true'/>
      <WorkItemConfig>
        <NotificationEmailTemplateRef>
          <Reference class='EmailTemplate' name='Account Selection Notification'/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
      <ValidatorScript>
        <Source>
          import sailpoint.object.AccountSelection;
          import sailpoint.tools.Util;

          // The return has not yet been processed since we're in the validator
          // script.  Grab the account selections from the work item.
          List accountSelections = item.getAttribute("accounts");

          // Make sure that all account selections have decisions.
          for (AccountSelection sel : accountSelections) {
              if (Util.isEmpty(sel.getSelectedNativeIdentities())) {
                  return "Please make a selection for each application.";
              }
          }
          return null;
        </Source>
      </ValidatorScript>
      <AfterScript>
        <Source>
          import sailpoint.object.Attributes;
          import sailpoint.api.Provisioner;

          // Set the account selections back on the project.  Later these will
          // be consulted when the native identities are resolved.
          List accountSelections = approval.get("accountSelectionsFromWorkItem");
          project.setAccountSelections(accountSelections);

          // Recompile project so that selected native identities get put into
          // provisioning plans.
          Provisioner p = new Provisioner(wfcontext.getSailPointContext());
          Attributes args = wfcontext.getStepArguments();
          p.recompile(project, args);
        </Source> 
      </AfterScript>
    </Approval>
    <Transition to='Recompile Provisioning Project'/>
  </Step>

  <Step action="call:recompileProject" name="Recompile Provisioning Project" posX="99" posY="112" resultVariable="project">
    <Description>
      Recompile the project.
    </Description>
    <Arg name='project' value='ref:project'/>
    <Transition to='Build Provisioning Form'/>
  </Step>
  
  <!--
      TODO: Can also pass preferredOwner and requiredOwner here, make
      those variables?
  -->
  <Step action="call:buildProvisioningForm" name="Build Provisioning Form" posX="99" posY="112" resultVariable="workItemForm">
    <Description>
      Call the standard handler method to build the provisioning form
      from the specified template and question list.
    </Description>
    <Arg name='project' value='ref:project'/>
    <Arg name='template' value='ref:formTemplate'/>
    <Arg name='owner' value='ref:requiredOwner'/>
    <Arg name='preferredOwner' value='ref:preferredOwner'/>
    <Arg name='fallbackOwner' value='ref:fallbackOwner'/>
    <Arg name='workItemComments' value='ref:workItemComments'/>
    <Arg name='workItemPriority' value='ref:priority'/>
    <Transition to='Present Provisioning Form'/>
  </Step>

  <!-- 
     TODO: Pass in the workItemDescription as a Variable?
  -->
  <Step condition="script:!isNull(workItemForm)" name="Present Provisioning Form" posX="99" posY="252">
    <Description>
      Present the form we calculated in the previous step.
      TODO: Need something more formal to determine who the owner
      of this should be.
    </Description>
    <Approval send='identityName,identityDisplayName,workItemForm,launcher' owner="script:workItemForm.getTargetUser()" return='workItemForm'>
      <Arg name='workItemType' value='Form'/>
      <Arg name='workItemDescription' value='Complete provisioning form for $(identityDisplayName)'/>
      <Arg name='workItemDisableNotification'>
        <Script>
          <Source>
            <![CDATA[
            // 
            // If this is interactive then don't bother sending email
            // notifications.
            // 
            // There is some subtle logic here. Basically requiredOwner
            // is null most of the time except in the case of pre-approval
            // forms. In that case we want to return the forms for the
            // required owner so they can fill it in during the request
            // process instead of waiting on a workitem.  
            //
            boolean disableEmail = false;
            String owner = ( requiredOwner != null ) ? requiredOwner : sessionOwner;
            if ( Util.nullSafeEq(owner, workItemForm.getTargetUser()) ) { 
                disableEmail = true;
            }
            return disableEmail;
            ]]>
          </Source>
        </Script>
      </Arg>
      <Arg name='workItemPriority' value='ref:priority'/>

      <WorkItemConfig>
        <NotificationEmailTemplateRef>
          <Reference class='EmailTemplate' name='Provisioning Form Notification'/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>

    </Approval>
    <!-- there is no reject, only assimilation -->
    <Transition to='Assimilate Provisioning Form'/>
  </Step>
  
  <Step action="call:assimilateProvisioningForm" condition="script:!isNull(workItemForm)" name="Assimilate Provisioning Form" posX="314" posY="252" resultVariable="project">
    <Description>
      Assimilate the results of the provisining form back into the workflow.
      This may result in the generation of another set of questions for
      a different user.  Assimilation can also theoretically generate new
      questions for the same user if some of the template fields had
      conditional rendering.

      You can pass things into the Template and Field scripts by
      defining Args in this step.  You cannot change plan copmiler
      options, those were specified in the call to compileProvisioningProject
      and stored in the project for recompilation and execution.

      A new project is returned, but actually it will always be the
      same as the project passed in.
    </Description>
    <Arg name='project' value='ref:project'/>
    <Arg name='form' value='ref:workItemForm'/>

    <Transition to='Build Provisioning Form'
                when='(project != null &amp;&amp; project.hasQuestions()) &amp;&amp; !isNull(workItemForm)'/>
    <Transition to='end'/>
  </Step>

  <Step icon="Stop" name="end" posX="853" posY="12"/>

</Workflow>

<!-- **********************************************************************

  Do Manual Actions

  Present the unmanaged portion of a provisioning project as work
  items to be processed manually.

  This is similar to approvals but uses a different renderer.

********************************************************************** -->

<Workflow name='Do Manual Actions'
          type='Subprocess'
          libraries='Identity'>
   <Description>
     Preset the unmanaged portion of a provisioning project as work items
     to be processed manually.  This is used by the IIQ workflows, Identity Update
     and Identity Refresh.  LCM has a similar step but it audits differently.
     Need to reconsider this and see if we can share the same subprocess.
   </Description>

  <!-- 
    Required for the call to auditManualAction in the after script. 
  -->
  <RuleLibraries>
    <Reference name="Approval Library" class="sailpoint.object.Rule"/>
  </RuleLibraries>

  <!--
    Input variables
  -->

  <Variable name='identityName' input='true' required='true'>
    <Description>
      The name of the identity object being modified.
    </Description>
  </Variable>

  <Variable name="identityDisplayName" input='true'
            initializer='script:(identityDisplayName != void) ? identityDisplayName : resolveDisplayName(identityName)'>
    <Description>
      The displayName of the identity being updated.
      This may be passed in, if not the script queries for this
      using a projection query and falls back to the name.
    </Description>
  </Variable>

  <Variable name='project' input='true' output='true' required='true'>
    <Description>
      A ProvisioningProject object describing the modifications to the identity.
    </Description>
  </Variable>
  
  <Variable name='priority' input='true'>
    <Description>
      String version of WorkItem.level that will be used
      to set the priority any generated workitems.
    </Description>
  </Variable>

  <Variable initializer="spadmin" input="true" name="fallbackApprover">
    <Description>
      A String that specifies the name of the Identity that will 
      be assigned any approvals where the owner of the approver 
      can't be resolved. Example if the scheme is "owner" and the 
      application doesn't specify and owner.
    </Description>
  </Variable>

  <Variable input="true" name="doAudit">
    <Description>
      When true we will audit the completion of manual action work items.
    </Description>
  </Variable>

  <Step icon="Approval" name="Manual Actions">
    <Description>
      Build an Approval structure for the unmanaged plan in the provisioning project.
      The construtor is in the rule "Build Manual Action Approvals" that expects
      to be passed launcher, project, identityName, and fallbackApprover.
    </Description>
    <Approval renderer='lcmManualActionsRenderer.xhtml' 
              mode="parallelPoll" 
              owner="rule:Build Manual Action Approvals" 
              send='identityDisplayName,identityName'>
      <Arg name='workItemRequester' value='$(launcher)'/>
      <Arg name='workItemDescription' value='Manual Changes requested for User: $(identityDisplayName)'/>
      <Arg name='workItemPriority' value='ref:priority'/>
      <Arg name='workItemType' value='ManualAction'/>
      <WorkItemConfig>
        <NotificationEmailTemplateRef>
          <Reference class='EmailTemplate' name='Pending Manual Changes'/>
        </NotificationEmailTemplateRef>
      </WorkItemConfig>
      <AfterScript>
        <Source>
          // Mark all items finished, LCM workflows do this for the dashboard
          // widget that tracks provisioning completion (the closed loop).
          // I'm not sure if we need that here, depends on which TaskResults
          // the scanner looks at, but be consistent.

          import sailpoint.object.ApprovalSet;
          import sailpoint.object.ApprovalItem;
          import sailpoint.object.WorkItem;

          // must be a leaf approval
          if (item != null) {
            ApprovalSet set = (ApprovalSet)item.get("approvalSet");
            if ( set != null ) {
                List approvalItems = set.getItems();
                for ( ApprovalItem approvalItem : approvalItems ) {
                    approvalItem.setState(WorkItem.State.Finished);
                }
            }

            // Audit the manual change
            // this is in LCM Workflow Library, if we think we need the
            // same level of auditing this will have to be brought over
            // to IdentityLibrary
            // if (doAudit)
            //   auditManualAction(item);
          }
        </Source> 
      </AfterScript>
    </Approval>
  </Step>

</Workflow>

<!-- **********************************************************************
  -
  - Provision with retries
  -
  -   Retries are handled in a loop of the workflow instead of launching
  -   a request.
  -
  ********************************************************************** -->

<Workflow name="Provision with retries"
          type='Subprocess'
          libraries="Identity,IdentityRequest">

  <Variable name='project' output='true' input='true' required='true'>
    <Description>
      Project that will be provisioned.
    </Description>
  </Variable>

  <Variable name='provisioningRetryThreshold' input='true' type='integer' 
            initializer='script:new Integer(60);'>
    <Description>
      The interval in minutes to wait to retry the request defaults to 
      60 minutes.  The retryInterval will be read from the underlying
      applications involved in the retry provisioning activity and
      the max interval defined across all applications will be used .
      If an interval is not specified on any of the Applications 
      we'll fall back to the setting in this variable which defaultws
      to an hour.
    </Description>
  </Variable>

  <Variable name='maxRetries' type='integer' input='true' editable='true'
            initializer='script:new Integer(-1);'>
    <Description>
       The maximum number of retries that will be attempted before failure 
       of the provisioning activities.  A value of -1 will execute
       retries indefinetly.
 
       Like provisioningRetry the value will be read from the
       application, if not defined on the application 
       we'll fall back to this setting which will default to -1.
    </Description>
  </Variable>

  <Variable name='enableRetryRequest' input='true' initializer='false'>
    <Description>
      When set to true it will disable the retries loop and let the 
      Provision step launch requests to handle the retries.  Enabling
      this flag will enable some older functionality.
    </Description>
  </Variable>

  <Variable name='foregroundProvisioning' editable='true' initializer='true' input='true'>
    <Description>
      Normally provisioning is done in a step that uses the "background"
      option to force the workflow to be suspend and be resumed in a
      background task thread.  This prevents the browser session from
      hanging since provision can sometimes take a long time.  For demos
      and testing it can be better to do this in the foreground so that
      provisioning will have been performed when control is returned to the
      user.  This prevents having to run the Perform Maintenance task to 
      see the resutls of the request.
    </Description>
  </Variable> 

  <Variable name='disableIdentityRequests' input='true'>
    <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
  </Variable> 

  <Variable name='identityRequestId' input='true'>
    <Description>
      The ID of the IdentityRequest for this request.
    </Description>
  </Variable>

  <Variable name='trace' input='true'>
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>

  <!-- out --> 
  <Variable name='retries' output='true' type='integer'>
    <Description>
       The number of retries performed during the execution
       of the provisioning activities.
    </Description>
  </Variable>

  <!-- local --> 
  <Variable name='retryProject'>
    <Description>
      Project that is assembled for retry purposes, the parts of
      original plan are broken into a separate plan that includes
      only the account requests that need to be retried.

      After each visit to retr this project will be rebuilt after
      the previous execution results are assimimlated back onto
      the "main" project.
    </Description>
  </Variable>
 
  <Step icon="Start" name="Start" posX="17" posY="104">
    <Transition to="Initialize Retries"/>
  </Step>

  <Step name="Initialize Retries" icon="Task" posX="101" posY="104">
    <Description>
      When visiting for the first time initalize the 
      retry variable and avoid the sleep that we'll 
      want when looping for retries.
    </Description>
    <Script>
      <Source>
        if ( retries == null ) { 
            retries = new Integer(0); 
        } else {
            retries++;
        }
        wfcontext.getWorkflowCase().put("retries", retries);
      </Source>
    </Script>
    <Transition to="Wait for next retry" when='script:(retries > 0)'/>
    <Transition to="Provision"/> 
  </Step>

  <Step name='Wait for next retry' wait='ref:retryInterval' posX="159" posY="17">
    <Description>
      This is a sleep step and just waits to execute the next step.
      Typically only called when we are retrying to give us some delay
      between calls down to the PE. Skipped during the first loop.
    </Description>
    <Transition to="Provision Retry"/>
  </Step>

  <Step name="Provision" action="call:provisionProject" icon="Provision" posX="258" posY="100">
    <Description> 
       Call the typical provisionProject method during our first time
       through the workflow.  If there are retries this step
       will be skipped and should fall into the "Retry Provision"
       step.

       The only thing special here is the flag we specify to
       the PlanEvaluator to prevent the Request object from
       from being created if there are retries in the project.
       Then we can handle them directly in the workflow looping 
       until we are complete.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Arg name='background' value='!ref:foregroundProvisioning'/>
    <Transition to="Refresh Identity Request"/>
  </Step>

  <Step name="Refresh Identity Request" action="call:refreshIdentityRequestAfterProvisioning" posX="365" posY="100">
    <Description> 
       Refresh the identity request to include provisioning results and
       any other provisioning side effects in the project.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
     <Transition to="Check for retry" when="!ref:enableRetryRequest"/>
     <Transition to="End" when="ref:enableRetryRequest"/>
  </Step>

  <Step name="Provision Retry" action="call:retryProvisionProject" icon="Provision" posX="421" posY="17"
        resultVariable='retryProject'>
    <Description> 
       Call retryProvisionProject method that will retry the plans
       in the project. Notice we pass in the retryProject which 
       contains only the parts of the main project that need
       to be retried.
    </Description>
    <Arg name="project" value="ref:retryProject"/>
    <Arg name="disableRetryRequest" value="true"/>
    <Transition to="Merge Retry Project Results"/>
  </Step>

  <Step name="Merge Retry Project Results" action="call:mergeRetryProjectResults" posX="603" posY="17"
        resultVariable='project'>
    <Description>
       Merge the results from the retry project back into the project.
       This step will take and items that are no longer marked rety
       over to the orginal project.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Arg name="retryProject" value="ref:retryProject"/>
    <Transition to="Check for retry"/>
  </Step>

  <Step name="Check for retry" icon="Task" action="call:assembleRetryProject" posX="603" posY="98"
        resultVariable="retryProject">
    <Description> 
       Dig into the project and look for things marked retryable.
       Build an new plan that contains only the retryable parts.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Transition to="Update Identity Request"/>
  </Step>

  <Step name="Update Identity Request" action="call:refreshIdentityRequestAfterRetry" condition="script:(retryProject != null)" posX="49" posY="262">
    <Description> 
       Update the Identity Request object with the retry details.
    </Description>
    <Arg name="project" value="ref:retryProject"/>
    <Transition to="Calculate Max Retry"/>
  </Step>

  <Step name="Calculate Max Retry" action="call:getProvisioningMaxRetries" posX="178" posY="262"
        resultVariable="maxRetries">
    <Description> 
       Calculate the maxRetries variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to a system config.

       Use the maxRetries to drive if we continue to loop or end.
    </Description> 
    <Arg name="project" value="ref:retryProject"/>
    <Transition to="Calculate Retry Threshold"/> 
  </Step>

  <Step name="Calculate Retry Threshold" action="call:getProvisioningRetryThreshold" posX="309" posY="262"
        resultVariable="retryInterval">
    <Description> 
       Calculate the retryInterval variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to the workflow setting.
    </Description> 
    <Arg name="project" value="ref:retryProject"/>
    
    <Transition to="Start" when='script:( ( retryProject != null ) &amp;&amp; ( maxRetries == -1 || retries &lt; maxRetries ) )'/>
    <Transition to="Timeout" when='script:( ( retryProject != null ) &amp;&amp;( retries &gt;= maxRetries ) )'/>
    <Transition to="Check for more provisioning"/>                
  </Step>
  
  <Step name="Check for more provisioning" resultVariable="project" posX="472" posY="259">
    <Description>
      Disable the reset of the project evaluation so the results 
      are maintained on the various levels of the plan. we will
      typically only revisit Provisioning when there are dependencies that were
      not executed because of a retry.
    </Description>
    <Script>
      <Source>
        if ( project.hasUnfinishedIntegrationPlans() ) {
            project.put("disableProjectReset", true);
        }
        return project;
      </Source>
    </Script>
    <Description>
      There may be cases when dependencies that were waiting on a dependency will still have to be fulfulled,
      for those cases loop back to provisioning.
    </Description>
    <Transition to="Provision" when='script: ( ( project != null ) &amp;&amp; (project.hasUnfinishedIntegrationPlans()) ) ;'/> 
    <Transition to="End"/>
  </Step>

  <Step name="Timeout" action="call:forceRetryTimeoutFailure" resultVariable="project" posX="374" posY="413">
    <Description> 
       Go back through the project and mark everything that was being
       retried to failure.
    </Description>    
    <Arg name="message" value="Retry timeout occured."/>
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
    <Arg name="retryProject" value="ref:retryProject"/>
    <Transition to="Update Identity Request with timeouts failures"/>
  </Step>
    
  <Step name="Update Identity Request with timeouts failures" posX="539" posY="413"
        action="call:refreshIdentityRequestAfterProvisioning">
    <Description> 
       Update the Identity Request object with the failures that were added to
       the project due to retry timeout.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Transition to="End"/>
  </Step>
  
  <Step icon="Stop" name="End" posX="695" posY="413"/>

</Workflow>

<!-- **********************************************************************
  -
  - Check Queued Provisioning Items
  -
  -  When there are queued items in the ProvisioningPlan?
  -
  ********************************************************************** -->

<Workflow name="Check Status of queued items"
          type='Subprocess'
          libraries="Identity,IdentityRequest">

  <Variable name='project' input='true' output='true' required='true'>
    <Description>
      Project that has account requests in the QUEUED state.
    </Description>
  </Variable>

  <Variable name='provisioningStatusCheckInterval' input='true' type='integer' 
            initializer='script:new Integer(60);'>
    <Description>
      The interval in minutes to retry the check status call,
      defaults to 1 hour.
    </Description>
  </Variable>

  <Variable name='provisioningMaxStatusChecks' type='integer' 
            initializer='script:new Integer(-1);'>
    <Description>
       The maximum number of status checks that will be tried before failure 
       of the provisioning activities.  A value of -1 will execute
       indefinetly, which is the default.
    </Description>
  </Variable>
  
  <Variable name='disableIdentityRequests' input='true'>
    <Description>
      May be passed by the calling workflow to disable processing of
      IdentityRequest objects after provisioning.  This option should
      be passed by any workflow that is not used by LCM and does not
      maintain the IdentityRequest model.  This avoids logging a warning
      when the IdentityRequest is not found.
    </Description>
  </Variable> 

  <Variable name='trace' input='true' initializer='false'>
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>

  <!-- out --> 
  <Variable name='statusChecks' output='true' type='integer'>
    <Description>
       The number of status checks performed during the execution
       of the provisioning activities.
    </Description>
  </Variable>
  
  <Step icon="Start" name="Start" posX="25" posY="233">
    <Transition to="Requires Check"/>
  </Step>
  
  <Step name="Requires Check" icon="Task" action="call:requiresStatusCheck" posX="134" posY="233"
        resultVariable='requiresStatusCheck'>
    <Description>
       Up front check to compute if the status check is necessary.

       Dig into the plan and check to see if any of the plan results have 
       queued items with requestIds??

       If both are not true, bail out -- otherwise enter a loop 
       that will checking for status.       
    </Description>
    <Arg name="project" value="ref:project"/>
    <Transition to="Initialize Status Checks" when='script:(requiresStatusCheck)'/>
    <Transition to="Apply Committed Results"/>
  </Step>

  <Step name="Initialize Status Checks" icon="Task" posX="192" posY="119">
    <Description>
      When visiting for the first time initalize the 
      statusChecks counter variable and avoid the sleep that we'll 
      want when looping while checking status.
    </Description>
    <Script>
      <Source>
        if ( statusChecks == null ) { 
            statusChecks = new Integer(0); 
        } else {
            statusChecks++;
        }
        wfcontext.getWorkflowCase().put("statusChecks", statusChecks);
      </Source>
    </Script>
    <Transition to="Calculate Max Checks"/> 
  </Step>

  <Step name="Calculate Max Checks" action="call:getProvisioningMaxStatusChecks" posX="344" posY="119"
        resultVariable="provisioningMaxStatusChecks">
    <Description> 
       Calculate the maxRetries variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to a system config.
    </Description> 
    <Transition to="Calculate StatusCheck Threshold"/> 
  </Step>

  <Step name="Calculate StatusCheck Threshold" action="call:getProvisioningStatusCheckInterval" posX="526" posY="119"
        resultVariable="provisioningCheckStatusInterval">
    <Description> 
       Calculate the provisioningStatusCheckInterval variable by digging into the
       retry project in an attempt to resolve the maxRetries 
       from the applications that are involved falling back
       to the workflow setting.
    </Description> 
    <Arg name="project" value="ref:project"/>
    <Transition to="CheckStatus" when='script:(statusChecks == 0)'/>
    <Transition to="Wait for next check"/>
  </Step>

  <Step name='Wait for next check' wait='ref:provisioningCheckStatusInterval' posX="584" posY="16">
    <Description>
       Pause and waiting for things to happen on the PE side.  
       Use the configurable interval to determine how long
       we wait in between checks.
    </Description>
    <Transition to="CheckStatus"/>
  </Step>

  <Step name="CheckStatus" action="call:checkProvisioningStatus" posX="730" posY="16"
        resultVariable="project">
    <Description> 
       Call the connector's checkStatus method for each queued item found in a project.
       This method will also update the status on the plan as items complete.
    </Description>
    <Arg name="project" value="ref:project"/>
  </Step>
  
  <Step name="Refresh Identity Request" action="call:refreshIdentityRequestAfterProvisioning" posX="730" posY="121">
    <Description> 
       Refresh the identity request to include provisioning results returned
       from the connector's checkStatus any other provisioning side effects updated in the project.
       
       This method gives us the update of each access request item so it can
       be displayed in the UI as they complete instead of waiting for
       the entire process to complete.
       
       Note that the disableIdentityRequests input variable is passed
       to skip request processing if we're being called from a non-LCM workflow.
       It is easier to pass this option than to transition around this step.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Arg name="disableIdentityRequests" value="ref:disableIdentityRequests"/>
    <Transition to="Requires Check" when='script:( provisioningMaxStatusChecks == -1 || statusChecks &lt; provisioningMaxStatusChecks)'/>
    <Transition to="Timeout" when='script:( statusChecks &gt;= provisioningMaxStatusChecks )'/>
    <Transition to="Apply Committed Results"/>
  </Step>
  
  <Step name="Timeout" action="call:addMessage" posX="916" posY="118">
    <Description> 
    </Description>
    <Arg name="message" value="Max number of status checks occurred."/>
    <Transition to="Apply Committed Results"/>
  </Step>
  
  <Step name="Apply Committed Results" icon="Task" posX="916" posY="229" action="call:applyCommittedResults" 
        condition="script: return (statusChecks != null );">
    <Description>
      Apply any of the commited plans, account requests or attribute requests 
      that result from our checking the request status.
    </Description>
    <Arg name="project" value="ref:project"/>
    <Transition to="End"/>
  </Step>
  
  <Step icon="Stop" name="End" posX="1116" posY="229"/>

</Workflow>

<!-- **********************************************************************
  -
  - Subprocess to handle ticket management (create, update) from the LCM 
  - workflows for the purposes of external sync or logging. 
  -
  ********************************************************************** -->
<Workflow name="Manage Ticket"
          type='Subprocess'
          libraries="Identity,IdentityRequest,Group">
         
  <Description>
   A workflow subprocss designed to allow service/help desk tickets opened
   or updated during the lifecycle of a workflow.
  </Description>

  <Variable name='project' input='true' required='true'>
    <Description>
      Project that is being provisioninged.
    </Description>
  </Variable>
  
  <Variable name='identityRequestId' input='true' output='true' required='true'>
    <Description>
      The ID of the IdentityRequest object which can can be used to read/update 
      the external ticket id. 
    </Description>
  </Variable>
  
  <Variable name='ticketManagementApplication' input='true' required='true'>
    <Description>
      Ticketing application that supports creating/updating objects of type ticket.
    </Description>
  </Variable>
  
  <Variable name='ticketDataGenerationRule' input='true'>
    <Description>
      A rule that builds up the ticketing provisioning plan based on the workflow
      context.  This rule gets all of the arguments to this subprocess 
      plus the curreent workflow context.  The rule can return either a 
      ProvisioningPlan or a Map of name value pairs. 
      
      The rule name can be specified here on the subprocess or on the 
      ticketManagementApplication config under the same name as this 
      variable.
    </Description>    
  </Variable>
  
  <Variable name='action' input='true' required='true'>  
    <Description>
      This is a breadcrumb given to the rule to help it generate the proper
      provisioning plan for the current injection point.  There will be several
      default injection points that will map to an action.
     
      OOTB There are four points which all workflow are injected and will map to the
      "actions" passed into this subprocess.
     
      open
      postApproval
      postProvisioning
      close
    </Description>       
  </Variable>    
  
  <Variable name='trace' input='true' initializer='true'>
    <Description>
      Used for debugging this subprocess and when set to true trace
      statements will be sent to stdout.
    </Description>
  </Variable>

  <Variable name='ticketPlan'>
    <Description>
      Plan that is generated during the processing of the ticektDataGenerationRule
      execution.  This will eventually be turned in to the ticketProject which can 
      be provisioned.
    </Description>
  </Variable>    
      
  <Variable name='ticketProject'>
    <Description>
      Variable that will hold our compiled project, that eventually will be 
      provisioned to the backend ticketing system.
    </Description>
  </Variable>    
  
  <Variable name='ticketId' output="true" input="true">
    <Description>
      Variable that will hold the ticketId, it may be passed in for update
      and will be returned on create.  If this value is null AND the
      its not a create action, the ticket id will be read from 
      the identityRequest.externalTicketId field.
    </Description>
  </Variable>
    
  <Variable name='priority' input='true'>
    <Description>
      String version of WorkItem.level that will be used
      to set the priority of any workitems.
    </Description>
  </Variable>  
    
  <Step icon="Start" name="Start" posX="27" posY="12"/>
        
  <Step name="Generate Ticket Plan" resultVariable='ticketPlan' action="call:generateTicketPlan" posX="132" posY="12">
    <Description>
      A workflow service that will call to the generation rule to help
      generate an 'ObjectRequest' based provisioning plan that will be used to 
      create/update the ticket.  If the rule returns a plan that plan will be 
      returned directly by the buildTicketPlan call.  the rule returns a Map it will 
      be converted into a provisioning plan.
    </Description>
    <Arg name="priority" value="ref:priority"/>
    <Arg name="project" value="ref:project"/>
    <Arg name="identityRequest" value="ref:identityRequest"/>
    <Arg name="action" value="ref:action"/>
    <Arg name="application" value="ref:ticketManagementApplication"/>
    <Arg name="rule" value="ref:ticketDataGenerationRule"/>
    <Arg name="ticketId" value="ref:ticketId"/>
  </Step>
  
  <Step name="Compile Ticket" resultVariable='ticketProject' action="call:compileGroupProject" posX="251" posY="12">
    <Description>
      Compile the generated plan in a project so it can be provisioned.
      These will normally compile down to a single targeted connector plan.      
    </Description>
    <Arg name="plan" value="ref:ticketPlan"/>
    <Arg name="requester" value="ref:launcher"/>
    <Arg name="source" value="ref:source"/>
    <Arg name="disableRetryRequest" value="true"/>
    <Arg name="optimisticProvisioning" value="false"/>
  </Step>
  
  <Step name="Provision Ticket" icon="Task" posX="379" posY="12">
    <Description>
      Call the standard subprocess to initialize the request, this includes
      auditing, building the approvalset, compiling the plan into 
      project and checking policy violations.
    </Description>
    <WorkflowRef>
      <Reference class='Workflow' name='Provision with retries'/>
    </WorkflowRef>
    <Arg name="priority" value="ref:priority"/>
    <Arg name="project" value="ref:ticketProject"/>
    <Arg name='foregroundProvisioning' value='true'/>
    <Arg name='trace' value='ref:trace'/>      
    <Return name='retries' to='retries'/> 
    <Return name='project' to='ticketProject'/>
     
    <Transition to="Update IdentityRequest External ID" />
  </Step>

  <Step name="Update IdentityRequest External ID" resultVariable="ticketId" action="call:updateExternalTicketId" condition="script:( action.startsWith(&quot;open&quot;) );" posX="551" posY="12">
    <Description>
      Typically only called once, after the create of the ticket. This call will update
      the IdentityRequest.externalTicketId with the returned ticketId (String).
    </Description>
    <Arg name="project" value="ref:ticketProject"/>
    <Arg name="application" value="ref:ticketManagementApplication"/>
  </Step>
   
  <Step icon="Stop" name="End" posX="722" posY="12"/>

</Workflow>
 
</sailpoint>
