<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">

<!-- (c) Copyright 2008 SailPoint Technologies, Inc., All Rights Reserved. -->

<sailpoint>

<!--
  Example Identity Correlation Rules

  Identity Correlation Rules are used to find identities where
  we can hang new accounts.

  There are two examples here
  1) Using the account's email address to find the identity
  2) Using the account's firstname and last name attributes

  A correlation rule must return a Map with one of the
  specified Return arguments.
-->
<Rule language='beanshell' name='Example Identity Email Correlation Rule'
      type='Correlation'>
  <Description>
   In this example we are going to use the new account's
   email address to try and locate an existing Identity
   to hang the new account from. This rule uses the email attribute
   on the identity object to attempt to find an owner
   for the incoming link.
  </Description>
  <Signature returnType='Map'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in correlation.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name='account'>
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name='link'>
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identityName'>
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries.
        </Description>
      </Argument>
      <Argument name='identityAttributeName'>
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeValue'>
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    Map returnMap = new HashMap();

    String email = account.getStringAttribute("email");
    if ( email != null ) {
        returnMap.put("identityAttributeName", "email");
        returnMap.put("identityAttributeValue", email);
    }
    return returnMap;
    ]]>
  </Source>
</Rule>

<Rule language='beanshell' name='Example Identity Name Correlation Rule'
      type='Correlation'>
  <Description>
   In this example we are trying to locate an existing Identity
   using the "firstname" and "lastname" attributes from the incoming
   account to generate a firstname.lastname formatted identity name.
  </Description>
  <Signature returnType='Map'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in correlation.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name='account'>
        <Description>
          A sailpoint.object.ResourceObject returned from the
          collector.
        </Description>
      </Argument>
      <Argument name='link'>
        <Description>
          Existing link to this account.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identityName'>
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeName'>
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeValue'>
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    Map returnMap = new HashMap();
    String firstname = account.getStringAttribute("firstname");
    String lastname = account.getStringAttribute("lastname");
    if ( ( firstname != null ) && ( lastname != null ) ) {
        String name= firstname + "." + lastname;
        returnMap.put("identityName", name);
    }
    return returnMap;
    ]]>
  </Source>
</Rule>

<!--
  Example IdentityCreation rule

  Identity creation rules are used to set attributes on new Identity
  objects when they are created.  New identities may be created during
  the aggregation of application accounts, or optionally created after
  pass-through authentication.

  One common operation is to change the name property of the identity
  when the default application name is complex (such as a directory DN).

  Another common operation is to assign a set of initial capabilities
  based on the attributes pulled from the application account.
-->
<Rule name='Example User Auto-Create Rule' language='beanshell'
      type='IdentityCreation'>

  <Description>
    Example rule to modify the given user that is being created during
    aggregation or after a non-correlated pass-through authentication.
    a non-correlated authentication attempt. In this example, if
    the account is part of the Administrator group, we give
    the new Identity the ApplicationAdministrator capability.
  </Description>

  <Signature returnType='Identity'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application being aggregated.
        </Description>
      </Argument>
      <Argument name='account' type='ResourceObject' required='true'>
        <Description>
          The resource account for the identity being created.
        </Description>
      </Argument>
      <Argument name='identity' type='Identity' required='true'>
        <Description>
          The identity that is being created.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Identity;
    import sailpoint.object.Capability;
    import sailpoint.object.ResourceObject;

    // change the name to a combination of firstname and lastname
    String firstname = account.getStringAttribute("firstname");
    String lastname = account.getStringAttribute("lastname");
    String name  = firstname + "." + lastname;
    identity.setName(name);

    // add capabilities based on group membership
    List groups = (List)account.getAttribute("memberOf");
    if ( ( groups != null ) && ( groups.contains("Administrator") ) ) {
        identity.add(context.getObjectByName(Capability.class, "ApplicationAdministrator"));
    }

    ]]>
  </Source>
</Rule>

<!--
  Example Identity Refresh rule.

  Identity refresh rules are called during aggregation and
  identity refresh tasks after all of the other operations have
  completed.  It provides a final hook for modifying the identity
  before it is persisted and we move on to the next identity.
-->
<Rule name='Example Identity Refresh Rule' language='beanshell'
      type='Refresh'>

  <Description>
    Example rule to modify the given user that has been aggregated or refreshed.
  </Description>

  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='environment' type='java.util.Map' required='true'>
        <Description>
          The task agruments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name='identity' type='Identity' required='true'>
        <Description>
          The identity that is being updated.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    import java.util.Date;

    // set a custom refresh date
    identity.setAttribute("myLastRefresh", new Date());
    ]]>
  </Source>
</Rule>


<!--
  Example Escalation Rule

  Escalation rules are used by the Escalator to figure out where
  to route notifiable items (work items or certification items)
  that have expired.

  Escalation rules return a string which specifies the name
  of the identity that should receive the escalated item.
-->
<Rule language='beanshell' name='Example WorkItem Escalation Rule'
      type='Escalation'>

  <Description>
    Example rule to escalate any workitems or certification
    items that are owned by curly to be re-assigned to larry
    and any items assigned to larry assigned to mo.
  </Description>

  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='item'>
        <Description>
          The sailpoint.object.Notifiable to escalate.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='newOwner'>
        <Description>
          The name of the Identity object that should be the new owner of
          the notifiable.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Identity;

    String newOwner = "curly";
    Identity currentOwner = item.getNotificationOwner(context);
    if ( currentOwner != null ) {
        String currentOwnerName =currentOwner.getName();
        if ( currentOwnerName.compareTo("curly") == 0 ) {
            newOwner = "larry";
        } else
        if ( currentOwnerName.compareTo("larry") == 0 ) {
            newOwner = "mo";
        }
    }
    return newOwner;
    ]]>
  </Source>
</Rule>

<!--
  Work Item Escalate to Active Manager Rule

  Escalation rules are also used by the maintenance task to reassign
  work items belonging to inactive personnel.

  Escalation rules return a string which specifies the name
  of the identity that should receive the escalated and/or forwarded item.
-->
<Rule language="beanshell" name="Work Item Escalate to Active Manager Rule" type="Escalation">
  <Description>
    Example rule to escalate notifiable items from inactive users to an active manager.
  </Description>

  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='item'>
        <Description>
          The sailpoint.object.Notifiable to forward.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='newOwner'>
        <Description>
          The name of the Identity object that should be the new owner of
          the item or null if no valid owner could be found.
        </Description>
      </Argument>
    </Returns>
  </Signature>

  <Source>
    <![CDATA[
    import sailpoint.object.Identity;

    Identity newOwner = item.getNotificationOwner(context);

    while (newOwner != null && newOwner.isInactive()) {
        newOwner = newOwner.getManager();
    }

    if (newOwner == null)
        return null;
    else
        return newOwner.getName();
    ]]>
  </Source>
</Rule>


<!--
  Example Policy Notification Rule

  Policy notification rules return a Map, which must contain a
  key, named identityName, that holds the name of the identity that
  should receive the policy violation notification.
-->
<Rule name="Example Policy Notification Rule" type="PolicyNotification">
  <Description>
    Example rule that can be used to determine who should be notified
    if there are policy violations.
  </Description>
  <Signature returnType='Map'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object
        </Description>
      </Argument>
      <Argument name='violation'>
        <Description>
          A sailpoint.object.PolicyViolation object
        </Description>
      </Argument>
      <Argument name='policy'>
        <Description>
          A sailpoint.object.Policy object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identityName'>
        <Description>
          The name of the identity that should be notified.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Identity;
    import sailpoint.object.PolicyViolation;

    Map returnMap = new HashMap();
    Identity violationActor = violation.getIdentity();
    if ( violationActor != null ) {
        Identity manager = violationActor.getManager();
        if ( manager != null ) {
            returnMap.put("identityName", manager.getName());
        }
    }
    return returnMap;
    ]]>
  </Source>
</Rule>

<!--
  Example Global Identity Attribute Rule

  Identity attribute rules are used in conditions where we don't
  have a one-to-one mapping between attribute and value and where
  multiple attributes might have to be used to define the value
  of an identity attribute.

  A global rule is called for each identity that is
  processed. A global rule can use the Identity's Link objects
  to get at the attribute values necessary to derive the
  identity attribute value.

  In this example the rule checks two account attributes
  to derive the value. First check with the hr app's job
  code then check the ad account's description field.
-->

<Rule name="Example Global Identity Attribute Rule" type="IdentityAttribute">
  <Description>
    Example rule that can be used to generate an identity attribute value.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name='attributeDefinition'>
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='attributeValue'>
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Application;
    import sailpoint.object.Attributes;
    import sailpoint.object.Link;
    import sailpoint.tools.GeneralException;

    String isContractor = "false";
    Application hrApp = context.getObject(Application.class, "HRApp");
    if ( hrApp == null ) {
          return isContractor;
//        throw new GeneralException("Could not find hr app!");
    }

    List hrAccounts = identity.getLinks(hrApp);
    if ( hrAccounts != null ) {
        for ( int i=0; i<hrAccounts.size(); i++ ) {
            Link hrLink = (Link)hrAccounts.get(i);
            Attributes attrs = hrLink.getAttributes();
            int userCode = attrs.getInt("userCode");
            if ( userCode == 6501 ) {
                isContractor = "true";
                break;
            }
        }
    }

    // If we don't find the correct userCode in hr also check
    // to see if the ad description has contractor in the
    // value
    if ( !isContractor ) {
        Application adApp = context.getObject(Application.class, "AD-Global");
        if ( adApp == null ) {
          return isContractor;
//        throw new GeneralException("Could not find hr app!");
        }
        List<Link> adAccounts = identity.getLinks(adApp);
        if ( adAccounts != null ) {
            for ( int i=0; i<adAccounts.size(); i++ ) {
                Link adLink = (Link)adAccounts.get(i);
                Attributes attrs = adLink.getAttributes();
                String description = attrs.getString("description");
                if ( description != null ) {
                    if ( description.contains("contractor") ) {
                        isContractor = true;
                        break;
                    }
                }
            }
        }
    }
    return isContractor;
    ]]>
  </Source>
</Rule>

<!--
  Example Application Identity Attribute Rule

  Identity attribute rules are used in conditions where we don't
  have a one-to-one mapping between attribute and value and where
  multiple attributes might have to be used to define the value
  of an identity attribute.

  An application specific rule is called for each link
  on the application specified with the rule. It's context is
  slightly different then a global rule and ALSO receives
  the Link that represents the account being aggregated.

  In this example we need just get the integer attribute
  userCode.  If the value is  6501, the account is
  a contractor.
-->
<Rule name="Example Application Identity Attribute Rule"
      type="IdentityAttribute">
  <Description>
    Example rule that can be used to generate an identity attribute value.
    This is an application specific attribute promotion rule and it will be
    called for each link found on the application specified along with
    this rule.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
           The Identity of the object where the account is
           assigned.
        </Description>
      </Argument>
      <Argument name='link'>
        <Description>
           The Link object that represents the account that is
           being processed.
        </Description>
      </Argument>
      <Argument name='attributeDefininition'>
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
      <Argument name='attributeSource'>
        <Description>
           The AttributeSource object from the AttributeDefinition.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='attributeValue'>
        <Description>
          The value of the attribute that should be populated. The rule
          should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Link;
    import sailpoint.object.Attributes;

    String isContractor = "false";
    Attributes attrs = link.getAttributes();
    if ( attrs != null ) {
        int userCode = attrs.getInt("userCode");
        if ( userCode == 6501 ) {
            isContractor = "true";
        }
    }
    return isContractor;
    ]]>
  </Source>
</Rule>

<!--
  Example Identity Attribute Rule for an Identity Attribute of type sailpoint.object.Identity

  The value returned by this rule is the name of the identity.
-->
<Rule name="Example Rule for Attribute of type Identity"
      type="IdentityAttribute">
  <Description>
    Example rule that can be used to generate an identity attribute value.
    The return value could be either name of the identity or 
    and identity object.
  </Description>
<Signature returnType="String">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="environment" type="Map">
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name="identity">
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name='link'>
        <Description>
           The Optional Link object that represents the account that is
           being processed. Please note that this will be present only if the source is of type Application Rule.
           It does not apply to Global Rule.
        </Description>
      </Argument>
      <Argument name="attributeDefinition">
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="attributeValue">
        <Description>
          The value returned is the name of the related identity.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
import sailpoint.object.Identity;
import sailpoint.object.Link;
import sailpoint.object.Filter;
import sailpoint.object.Attributes;
import sailpoint.object.QueryOptions;

        Identity relatedIdentity = null;
        
        Attributes attrs = link.getAttributes();
        if ( attrs != null ) {
            String managerId = attrs.getString("managerId");
            QueryOptions options = new QueryOptions();
            options.addFilter(Filter.eq("empId", managerId));
            Iterator iterator = context.search(Identity.class, options);
            if (iterator.hasNext()) {
                relatedIdentity = iterator.next();
            }
        } 
        
        return relatedIdentity;
    ]]>
  </Source>
</Rule>


<!--
  Example Change Notification Rule

  Change notification rules may be configured to run whenever
  we detect an identity attribute changes during
  aggregation or refresh.
-->
<Rule language='beanshell' name='Example Change Notification Rule'
      type='Listener'>
  <Description>
    Rule that may be configured on an identity attribute.
    It will be called during aggregation or refresh if
    the attribute value chanages.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
          Arguments to the aggregation task.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          The Identity we are refreshing.
        </Description>
      </Argument>
      <Argument name='attributeDefinition'>
        <Description>
          The AttributeDefinition of the attribute that has changed.
        </Description>
      </Argument>
      <Argument name='attributeName'>
        <Description>
          The name of the attribute that has changed.
        </Description>
      </Argument>
      <Argument name='oldValue'>
        <Description>
          The previous value of the attribute.
        </Description>
      </Argument>
      <Argument name='newValue'>
        <Description>
          The new value of the attribute.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    ]]>
  </Source>
</Rule>

<!--
  Example Activity Correlation Rule

  ActivityCorrelation Rules are used by the Activity Correlator
  to find Identity that performed the activities. Most data sources
  will return a name, which may or may not be what we store as the
  Link's identity.
-->
<Rule language='beanshell' name='Example Activity Correlation Rule'
      type='ActivityCorrelation'>

  <Description>
    Example rule to show how an activity might be correlated
    back to an identity. In most cases, this rule will be providing
    enought information to the correlator so that it can find the
    Application link. In some cases, it might also
    be desireable to return something that points
    back to an Identity, which is also supported.
  </Description>

  <Signature returnType='Map'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in correlation.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The application where the activity was generated.
          An application may have more then one data source.
        </Description>
      </Argument>
      <Argument name='datasource'>
        <Description>
          The data source that returned the activity.
        </Description>
      </Argument>
      <Argument name='activity'>
        <Description>
          The activity object that was normalized by
          the data source and that we are trying to
          correlate back to one of our Identities.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='linkIdentity'>
        <Description>
          A string that represents the link's identity attribute.
        </Description>
      </Argument>
      <Argument name='linkName'>
        <Description>
          A string that represents the link's displayName attribute.
        </Description>
      </Argument>
      <Argument name='linkAttributeName'>
        <Description>
          A string that represents the NAME of an attribute that
          can be used to find the Link that maps back to this
          activity.  This attribute must also be supplied
          with the linkAttributeValue variable.
        </Description>
      </Argument>
      <Argument name='linkAttributeValue'>
        <Description>
          A string that represents the VALUE of an attribute that
          can be used to find the Link that maps back to this
          activity. This attribute must also be supplied
          with the linkAttributeName variable.
        </Description>
      </Argument>
      <Argument name='identityName'>
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          A fully resolved Identity object in case the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeName'>
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeValue'>
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.ApplicationActivity;

    String user = activity.getUser();
    Map returnMap = new HashMap();
    if ( user != null ) {
        returnMap.put("linkAttributeName", "samAccountName");
        returnMap.put("linkAttributeValue", user);
    }
    return returnMap;
    ]]>
  </Source>
</Rule>

<!--
  Example Activity Transformation Rule

  ActivityTransformation Rules are used by the LogFileCollector to
  transform fields parsed from a text file into our ApplicationActivity
  model.
-->
<Rule name="Example CSV Activity Action Transformation Rule"
      type="ActivityTransformer">
  <Description>
    Example rule that converts the incoming action string
    from a log field into a
    sailpoint.object.ApplicationActivity.Action object.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='action'>
        <Description>
          The field named action, which is the raw parsed
          action field.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='mappedAction'>
        <Description>
          A normalized ApplicationActivity.Action object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.ApplicationActivity.Action;

    Action mappedAction = null;
    if ( action.compareTo("Created") == 0 ) {
        mappedAction = Action.Create;
    } else
    if ( action.compareTo("Updated") == 0 ) {
        mappedAction = Action.Update;
    } else
    if ( action.compareTo("Deleted") == 0 ) {
        mappedAction = Action.Delete;
    } else {
        mappedAction = Action.valueOf((String)action);
    }
    return mappedAction;
    ]]>
  </Source>
</Rule>

<!--
  Example Manager Correlation Rule

  A rule called to help IdentityIQ take a value from the mapped
  manager field and map it to an existing IdentityIQ identity.

  Just like identity correlation, the rule needs to return a
  map that contains some values that will guide the correlator
  on how to try to find the identity.  It can also do the lookup
  manually and just returned the identity.
  e.g.
      Lets say we have an application named fooApp that defines
      an attribute named "reportsToEmail". The value of this
      attribute maps to the emailAddress for the user's
      manager.

      Identity were processing:
      reportsToEmail=dhildebrand@sailpoint.com

      Managers identity:
      emailAddress=dhildebrand@sailpoint.com

      In the identityConfig we've sourced our manager
      attribute with the "fooApp" reportsToEmail
      attribute.

      Additionally, we would have to map the fooApp's
      emailAddress attribute to one of our extendedAttributes.
      Lets for this example pretend we also named that attribute
      emailAddress.

      We could proably reuse the emailAddress
      field, but for the sake of this example lets just act
      as we are using an extended attribute.

      NOTE: This attribute should also be indexed for performance.
      For this example the rule would return a map with two values

      identityAttributeName=emailAddress
      identityAttributeValue=dhildebrand@sailpoint.com
-->
<Rule name="Example Manager Correlation Rule"
      type="ManagerCorrelation">
  <Description>
    A rule called to help IdentityIQ take a value from the mapped
  manager field and map it to an existing IdentityIQ identity.

  Just like identity correlation, the rule needs to return a
  map that contains some values that will guide the correlator
  on how to try to find the identity.  It can also do the lookup
  manually and just returned the identity.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
          Arguments passed to the aggregation task.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The application the aggregated account is from.
        </Description>
      </Argument>
      <Argument name='instance'>
        <Description>
          Optional instance identifier within the application.
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
          A connector to the attribute source.
        </Description>
      </Argument>
      <Argument name='link'>
        <Description>
          Account link of the referencing identity.
        </Description>
      </Argument>
      <Argument name='managerAttributeValue'>
        <Description>
          Attribute value that is stored in the manager attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identityName'>
        <Description>
          The name of an Identity object.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          A fully resolved Identity object if the rule wants
          to do its own queries to locate the identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeName'>
        <Description>
          The name of the extended attribute that can be used
          to locate an existing identity.
        </Description>
      </Argument>
      <Argument name='identityAttributeValue'>
        <Description>
          The value of the named extended attribute that can be used
          to locate an existing identity. This attribute is used
          together with the identityAttributeName argument.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      Map returnMap = new HashMap();
      if ( managerAttributeValue != null ) {
          returnMap.put("identityAttributeName", "emailAddress");
          returnMap.put("identityAttributeValue", managerAttributeValue);
      }
      return returnMap;
    ]]>
  </Source>
</Rule>

<Rule language="beanshell" name="Example SiteMinder SSO Rule" type="SSOAuthentication">
  <Description>
  In this example, header values set by the authentication service are used to
  find an Link when validating the SSO request.
  </Description>
  <Source>
    <![CDATA[
        import sailpoint.object.Application;
        import sailpoint.object.Identity;
        import sailpoint.object.Link;
        import sailpoint.tools.GeneralException;
        import sailpoint.api.Correlator;
        import sailpoint.api.SailPointContext;

        import javax.servlet.http.HttpServletRequest;
        import javax.servlet.http.HttpSession;

        private String COOKIE_TOKEN = "SMSESSION";
        private String COOKIE = "cookie";
        private String TRANSACTION_ID = "smtransactionid";
        private String SERVER_SESSION = "smserversessionid";
        private String AUTHDIR_OID = "smauthdiroid";
        private String AUTHDIR_SERVER = "smauthdirserver";
        private String AUTHDIR_NAME = "smauthdirname";
        private String USER_DN = "smuserdn";

        private String[] HEADER_ATTRS = { TRANSACTION_ID, SERVER_SESSION, AUTHDIR_SERVER, AUTHDIR_NAME, USER_DN, COOKIE };

        private String TEST_AUTHDIR ="HouseboatSunDS";
        private String TEST_IIQ_APP ="ssoapp";

        /**
         * Make sure we the values we know about.. this may vary with
         * various versions of SiteMinder.
         */
        private void validateHeader() {
            for ( String header : HEADER_ATTRS ) {
                String value = httpRequest.getHeader(header);
                if ( value == null ) {
                    throw new GeneralException("Invalid Site-Minder session."+
                               " Missing variable [" +header+"]");
                }
            }
        }

        /**
         * Use the authorization directory that siteminder put in
         * the header. Attempt to map the authdir to a SailPoint Application
         * where accounts for the authdir have been aggregated.
         */
        private Application mapAuthDirToApp(SailPointContext context,
                                            String authDir)
            throws GeneralException {

            Application app = null;
            if ( authDir.compareTo(TEST_AUTHDIR) == 0 ) {
                app = context.getObject(Application.class,TEST_IIQ_APP);
            } else {
                throw new GeneralException("Unable to map ["+authDir+
                         "] to an application defined in IdentityIQ.");
            }
            return app;
        }

        /**
         * For debug purposes.
         */
        private void dumpHeader() {
            Enumeration headerNames = httpRequest.getHeaderNames();
            if ( headerNames != null ) {
                while ( headerNames.hasMoreElements() ) {
                    String header = (String)headerNames.nextElement();
                    String value = httpRequest.getHeader(header);
                    System.out.println("HEADER["+header+"] VALUE["+ value+"]");
                }
            }
        }

//        dumpHeader();
        // Make sure everything we need is there, along with a few
        // other interesting values
        validateHeader();

        String userDn = httpRequest.getHeader(USER_DN);
        String authServer = httpRequest.getHeader(AUTHDIR_NAME);

        // Ask the correlator to find us the Link associated with the
        // userDn we stripped from the header
        Application app = mapAuthDirToApp(ctx,authServer);
        Correlator correlator = new Correlator(ctx);
        // second argument is instance which is not used in this example
        Link link = correlator.findLinkByNativeIdentity(app, null, userDn);

        if ( link == null ) {
            throw new GeneralException("Unable to find Link associated with ["
                           +userDn+"] on application ["+app.getName()+"]");
        }
        return link;
    ]]>
  </Source>
</Rule>

<Rule language="beanshell" name="Example SSO Validation Rule" 
      type="SSOValidation">
  <Description>
  In this example, header values set by the authentication service are used to
  find an Identity, thus validating the SSO request.
  </Description>
  <Source>
    <![CDATA[
      import javax.servlet.http.HttpServletRequest;
      import javax.servlet.http.HttpSession;
    
      private String getValueFromCookie(String cookie, String field) {
          if (null != cookie) {
              int tokenIndex = cookie.indexOf(field);
              if (tokenIndex >= 0) {
                  // if we found the attribute in the cookie
                  int valueStartIndex = cookie.indexOf("=", tokenIndex);
                  if (valueStartIndex >= 0) {
                      int valueEndIndex = cookie.indexOf(";", valueStartIndex);
                      if (valueEndIndex < 0) {
                          valueEndIndex = cookie.length();
                      }
                      String cookieValue = cookie.substring(valueStartIndex + 1, valueEndIndex);
                      // System.out.println("Cookie field: [" + field + "] value: [" + cookieValue + "]");
                      return cookieValue;
                  }
              }
          }
        
          return null;
      }
      
      /**
        * For debug purposes.
        */
      private void dumpHeader() {
          Enumeration headerNames = httpRequest.getHeaderNames();
          if ( headerNames != null ) {
              while ( headerNames.hasMoreElements() ) {
                  String header = (String)headerNames.nextElement();
                  String value = httpRequest.getHeader(header);
                  System.out.println("HEADER["+header+"] VALUE["+ value+"]");
              }
          }
      }
    
      // dumpHeader();
      
      String cookie = httpRequest.getHeader("Cookie");
      String smSessionToken = getValueFromCookie(cookie, "SMSESSION");
      HttpSession httpSession = httpRequest.getSession(false);
      
      // System.out.println("Siteminder session token: " + smSessionToken);
      
      // At this point you could use Siteminder's AgentAPI.decodeSSOToken()
      // to validate the session.  If there was a problem, you could:
      
      // return "Couldn't validate session because there was a problem";
      
      // or if successful, just:
      return null;
    
    ]]>
  </Source>
</Rule>

<!--
  Example Rule for correlating file targets back to Identities and
  ManagedAttributes representing groups.
-->
<Rule language="beanshell" name="Example WindowsSidTargetCorrelator Rule"
      type="TargetCorrelation">
  <Description>

  </Description>
  <Source>
    <![CDATA[
      import sailpoint.api.Correlator;
      import sailpoint.tools.xml.XMLObjectFactory;

      private String ATTR_OBJECT_SID = "objectSid";
      Map returnMap = new HashMap();
      if ( isGroup ) {
          returnMap.put(Correlator.RULE_RETURN_GROUP_ATTRIBUTE,ATTR_OBJECT_SID);
          returnMap.put(Correlator.RULE_RETURN_GROUP_ATTRIBUTE_VALUE, nativeId);
      } else {
          returnMap.put(Correlator.RULE_RETURN_LINK_ATTRIBUTE, ATTR_OBJECT_SID);
          returnMap.put(Correlator.RULE_RETURN_LINK_ATTRIBUTE_VALUE, nativeId);
      }
//System.out.println("Incomming ["+nativeId+"] correlated ["+XMLObjectFactory.getInstance().toXml(returnMap)+"]");
      return returnMap;
    ]]>
  </Source>
</Rule>

<!--
 Example Resource Object Customization Rule

 In rule is configured on the application and is called after the
 connector has build a ResourceObject from the native application
 data.

 Initially designed for non-rule based connectors to add SPPrivileged
 flag to an object, but could be used to do any transformations.

 This example checks the account's group list, and if it finds the
 Domain Admins group it sets the privileged flag. This flag will cause
 the account (Link) to be markedf privileged.

 This rule returns the modified ResourceObject.
-->
<Rule language="beanshell" name="Example Resource Object Customization Rule"
      type="ResourceObjectCustomization">
  <Description>
 This example checks the account's group list, and if it finds the
 Domain Admins group it sets the privileged flag. This flag will cause
 the account (Link) to be markedf privileged.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application that references the connector
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
          The connector object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='A ResourceObject'>
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.tools.xml.XMLObjectFactory;

      List groups = (List)object.getAttribute("memberOf");
      if ( groups != null ) {
          for ( String group : groups ) {
              if ( ( group != null ) &&
                   ( group.startsWith("cn=Domain Admins") ) ) {
                  object.put("isAdmin", true);
              }
          }
      }
//System.out.println("customized ro["+XMLObjectFactory.getInstance().toXml(object)+"]");
      return object;
    ]]>
  </Source>
</Rule>

<!--
 Example Ceritification Exclusion Rule
-->
<Rule language="beanshell" name="Exclude Inactive Identities"
      type="CertificationExclusion">
  <Description>
    This rule is an example Certification Exclusion rule that removes all
    of the certifiable items from a certification if the identity being
    certified is marked as inactive.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context' type='SailPointContext'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query
          the system or execute other SailPointContext services.
        </Description>
      </Argument>
      <Argument name='entity' type='AbstractCertifiableEntity'>
        <Description>
          The AbstractCertifiableEntity that is part of the certification.
          Currently, this is either an Identity, AccountGroup, or Bundle.
        </Description>
      </Argument>
      <Argument name='certification' type='Certification'>
        <Description>
          The certification that this identity is part of.
        </Description>
      </Argument>
      <Argument name='certContext' type='CertificationContext'>
        <Description>
          The CertificationContext that is being used to generate the
          certification.
        </Description>
      </Argument>
      <Argument name='items' type='List'>
        <Description>
          List of Certifiable items that are currently part of the
          certification for this identity.  Any items that should be excluded
          from the certification should be deleted from this list and added
          to the itemsToExclude list.
        </Description>
      </Argument>
      <Argument name='itemsToExclude' type='List'>
        <Description>
          A List of Certifiable items that should not be included in the
          certification.  This list will be empty when the rule is executed
          and any items that should not be part of the certification should
          be moved from the items list to the itemsToExclude list.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='explanation' type='String'>
        <Description>
          An optional explanation describing why the items were excluded.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
        // if the identity is inactive, then add all of the items to the
        // exclude list
    if ( identity.isInactive() ) {
      itemsToExclude.addAll(items);
      items.clear();
    }

    // No explanation.
    return null;
    ]]>
  </Source>
</Rule>

<!--
 Example Ceritification Exclusion Rule that excludes accounts that are part of
 a composite account.
-->
<Rule language="beanshell" name="Exclude Composite Accounts"
      type="CertificationExclusion">
  <Description>
  This rule splits the certifiables in the items and itemsToExclude list based on
 whether the certifiable is an "Exception" on an account that is a part of a
 composite account.  If we determine that the account is part of a composite
 account, the item is removed from the items list and added to the
 itemsToExclude list.
  </Description>
  <Signature>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.Application;
      import sailpoint.object.Certifiable;
      import sailpoint.object.Entitlements;
      import sailpoint.object.Link;

      StringBuffer explanation = new StringBuffer();
      Collection explainedAccounts = new HashSet();

      for (Iterator it = items.iterator(); it.hasNext(); ) {
          Certifiable certifiable = (Certifiable) it.next();
          if (certifiable instanceof Entitlements) {
              Entitlements ents = (Entitlements) certifiable;
              Application app = ents.getApplicationObject(context);
              String nativeIdentity = ents.getNativeIdentity();

              Link composite = identity.getOwningCompositeLink(app, nativeIdentity);

              // Non-null means that this is a component of a composite
              // link, so we will exclude it.
              if (null != composite) {
                  it.remove();
                  itemsToExclude.add(certifiable);

                  String acct = app.getName() + "-" + nativeIdentity;
                  if (!explainedAccounts.contains(acct)) {
                      explainedAccounts.add(acct);

                      if (explanation.length() > 0) {
                          explanation.append("  ");
                      }
                      explanation.append("Account " + nativeIdentity + " on " + app.getName() +
                                         " excluded because it is part of a composite account.");
                  }
              }
          }
      }

      return (0 != explanation.length()) ? explanation.toString() : null;
    ]]>
  </Source>
</Rule>


<Rule name="Native Identity Composite Account Rule" type="CompositeAccount">
  <Description>
 This is an account rule used by the RuleCompositeConnector that creates
 composite links if the given Identity has Links for all applications in the
 "tiers" resource attribute, and all of these links share the same native
 identity.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
          The Identity currently being processed.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The composite application.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='compositeLink'>
        <Description>
          A single composite Link or a Collection of composite Links.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source><![CDATA[
    import sailpoint.object.Application;
    import sailpoint.object.Identity;
    import sailpoint.object.Link;

    List composites = null;

    // Get the tiers, the names are passed through the Application.
    List tiers = application.getAttributeValue("tiers");

    if (tiers == null || tiers.size() < 2) {
      log.error("Must have two or more application names specified.");
      return null;
    }

    // Get links for all tiers.
    List apps = new ArrayList(tiers.size());
    Map linksByApp = new HashMap(tiers.size());

    for (Iterator it=tiers.iterator(); it.hasNext(); ) {
      String appName = (String) it.next();
      Application app = context.getObject(Application.class, appName);
      if (null != app) {
        List links = identity.getLinks(app);
        if ((null != links) && !links.isEmpty()) {
          apps.add(app);
          linksByApp.put(app, links);
        }
      }
    }

    // if we have at least one account in each tier
    if (tiers.size() == linksByApp.size()) {

      List topTierLinks = (List) linksByApp.get(apps.get(0));

      // Iterate over all links in the top tier and check if all other tiers
      // have an account with the same native identity.
      for (int i = 0 ; i < topTierLinks.size() ; i++) {
        Link link1 = (Link) topTierLinks.get(i);
        String id = link1.getNativeIdentity();

        List componentLinks = new ArrayList();

        // Other tiers must have a link with the same name.  We're starting
        // at index 1 because we're already looking at the top tier app.
        for (int j = 1 ; j < apps.size() ; j++) {
          Application app = (Application) apps.get(j);
          List linksForTier = (List) linksByApp.get(app);

          boolean foundMatchInTier = false;
          for (Iterator it=linksForTier.iterator(); it.hasNext(); ) {
            Link link2 = (Link) it.next();
            if (id.equals(link2.getNativeIdentity())) {
              componentLinks.add(link2);
              foundMatchInTier = true;
              break;
            }
          }

          // If we didn't find a match, quit looking.
          if (!foundMatchInTier) {
            break;
          }
        }

        Link composite = null;

        // If we have components in all tiers, we found a composite account.
        if (componentLinks.size() == apps.size() - 1) {
          composite = new Link();
          composite.setApplication(application);
          composite.setNativeIdentity(id);
          composite.addComponent(link1);

          for (Iterator it = componentLinks.iterator(); it.hasNext(); ) {
            composite.addComponent((Link) it.next());
          }
        }

        // outer loop: continue processing top tier accounts in case
        // we have more than one stack
        if (composite != null) {
          if (composites == null)
            composites = new ArrayList();
          composites.add(composite);
        }
      }
    }

    return composites;
  ]]></Source>
</Rule>

<!-- 
    This rule is invoked when a Work Item is opened or forwarded
  from the UI.
 -->
<Rule language='beanshell' name='Example Work Item Forward to Valid Email'
      type='WorkItemForward'>
  <Description>
  This example checks the Identity that owns the work item for an email address.
  If there's no email address for the Identity, the rule trolls up the management
  chain until it finds a manager with an email, then assigns that person to be the
  owner of the work item.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context' type='SailPointContext'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query
          the system or execute other SailPointContext services.
        </Description>
      </Argument>
      <Argument name='item'>
        <Description>
          The WorkItem being opened or forwarded.
        </Description>
      </Argument>
      <Argument name='owner'>
        <Description>
          The Identity that currently owns the work item.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='newOwner'>
        <Description>
          An Identity that should own the work item.  Alternatively, this can
          be a String that is the name or id of the Identity.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
        import sailpoint.object.Identity;

        // System.out.println("Input: " + identity);
        Identity newOwner = identity;

        String email = identity.getEmail();
        // System.out.println("  email: " + email);
        if ( email == null || email.length() == 0 ) {
            newOwner = identity.getManager();
            // System.out.println("newOwner: " + newOwner);
            while ( newOwner != null ) {
                email = newOwner.getEmail();
                // System.out.println("  email: " + email);
                if ( email != null && email.length() > 0 )
                    break;
                newOwner = newOwner.getManager();
            }
        }

        if ( email == null || email.length() == 0 ) {
                // This means that we did not find an identity with an email,
                // so what should we do?  This will default to not changing the
                // owner, but it could also assign it to a fixed user.
            newOwner = identity;
            // System.out.println("no owner with email found");
        }

        // System.out.println("Output: " + newOwner);
        // System.out.println("");

        return newOwner;
    ]]>
  </Source>
</Rule>

<Rule language='beanshell' name='Example Group Owner Assignment'
      type='GroupOwner'>
  <Description>
    A rule used to assign owners to groups generated from a group factory.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context' type='SailPointContext'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query
          the system or execute other SailPointContext services.
        </Description>
      </Argument>
      <Argument name='factory'>
        <Description>
          The GroupFactory that generated the populations.
        </Description>
      </Argument>
      <Argument name='group'>
        <Description>
          One GroupDefinition from the factory.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='owner'>
        <Description>
          The group owner.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
        return "spadmin";
    ]]>
  </Source>
</Rule>

<Rule language='beanshell' name='Example Certifier Assignment'
      type='Certifier'>
  <Description>
    A rule used to assign certifiers to populations generated
    from a group factory.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context' type='SailPointContext'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query
          the system or execute other SailPointContext services.
        </Description>
      </Argument>
      <Argument name='factory'>
        <Description>
          The GroupFactory that generated the populations.
        </Description>
      </Argument>
      <Argument name='group'>
        <Description>
          One GroupDefinition from the factory.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='certifiers'>
        <Description>
          A String, List&lt;String>, Identity, or a List&lt;Identity>.
          When returning strings, the string must be the name or id
          of an Identity.  When returning a single string, the string
          may be formatted as a CSV of Identity names or ids.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
        return "spadmin";
    ]]>
  </Source>
</Rule>


<Rule language="beanshell" name="Example Certification Pre-delegation Rule"
      type="CertificationPreDelegation">
  <Description>
   A pre-delegation rule is run on every CertificationEntity when the
   certification is generated in order to cause some entities to be
   pre-delegated.  As an example, a manager certification could pre-delegate
   the certification responsibility to each employee that reports to the
   manager.  This would allow each subordinate to first determine what they
   need access to, then allow the manager to review their decision.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name="context">
        <Description>
          The SailPointContext to use.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification being created.
        </Description>
      </Argument>
      <Argument name="entity">
        <Description>
          The sailpoint.object.CertificationEntity to possibly pre-delegate.
        </Description>
      </Argument>
      <Argument name="certContext">
        <Description>
          The sailpoint.api.CertificationContext generating this certification.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='recipientName'>
        <Description>
        The name of the Identity that should certify this entity.  Either
        this or 'recipient' should be non-null if pre-delegation should be
        performed.
        </Description>
      </Argument>
      <Argument name='recipient'>
        <Description>
        The Identity that should certify this entity.  Either this or
        'recipientName' should be non-null if pre-delegation should be
        performed.
        </Description>
      </Argument>
      <Argument name='description'>
        <Description>
        Optional description to set on the delegation WorkItem.  If null, a
        default description of "Certify [entity name]" is used.
        </Description>
      </Argument>
      <Argument name='comments'>
        <Description>
        Optional comments to set on the delegation WorkItems.
        </Description>
      </Argument>
      <Argument name='reassign'>
        <Description>
        Optional boolean to specify to reassign rather than delegate.
        </Description>
      </Argument>
      <Argument name='certificationName'>
        <Description>
        Optional String to specify the name for the reassignment certification
        if creating a new certification for reassignment.  This is ignored for
        delegations.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Identity;

    Map results = new HashMap();
    results.put("recipient", context.getObjectByName(Identity.class, "spadmin"));
    results.put("description", "Please certify " + entity.getFullname());
    results.put("comments",
                "Please determine the appropriate access for " +
                entity.getFullname() + " within the next 5 business days.");

    return results;
    ]]>
  </Source>
</Rule>

<Rule language="beanshell" name="Example Certification Entity Customization Rule"
      type="CertificationEntityCustomization">
  <Description>
   A CertificationEntity customization rule is run when a certification is
   generated to allow the CertificationEntity to be customized.  For example,
   default values can be calculated for the custom fields.
  </Description>
  <Signature>
    <Inputs>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext to use.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification to which the item is being added.
        </Description>
      </Argument>
      <Argument name="certifiable">
        <Description>
          The sailpoint.object.Certifiable item for which the item is being
          created.
        </Description>
      </Argument>
      <Argument name="certifiableEntity">
        <Description>
          The sailpoint.object.AbstractCertifiableEntity from which the
          certifiable was retrieved.
        </Description>
      </Argument>
      <Argument name="certContext">
        <Description>
          The sailpoint.api.CertificationContext that is being used to build the
          certification.
        </Description>
      </Argument>
      <Argument name="entity">
        <Description>
          The sailpoint.object.CertificationEntity to be customized.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    // Add interesting logic here.
    entity.setCustom1("custom attribute 1");
    entity.setCustom2("custom attribute 2");

    Map customMap = new HashMap();
    customMap.put("custom int field", 42);
    entity.setCustomMap(customMap);
    ]]>
  </Source>
</Rule>

<Rule language="beanshell" name="Example Certification Entity Completion Rule"
      type="CertificationEntityCompletion">
  <Description>
   A CertificationEntity completion rule is run when a CertificationEntity is
   refreshed and has been determined to be otherwise complete (ie - all items on
   the entity are complete).  This rule determines whether the entity is still
   missing any information.  For example, the entity may require a "classification"
   value to be present in a custom field to be complete.  If errors are found,
   the error messages (either plain-text messages or keys that map to messages
   in the custom message catalog) are added to a List and returned to the caller.
  </Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification being refreshed.
        </Description>
      </Argument>
      <Argument name="entity">
        <Description>
          The sailpoint.object.CertificationEntity being refreshed.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='messages'>
        <Description>
        A List of Message objects if errors were found; null otherwise.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import java.util.List;
    import java.util.ArrayList;
    import java.util.Map;
    import java.util.HashMap;

    List errors = new ArrayList();

    String e1 = entity.getCustom1();
    String e2 = entity.getCustom2();
    String scale = null;
    int cost = -1;

    Map extendedMap = entity.getCustomMap();
    if (null != extendedMap) {
        scale = (String) extendedMap.get("priceScale");
        Integer costInteger = (Integer) extendedMap.get("cost");
        if (null != costInteger) {
            cost = costInteger.intValue();
        }
    }

    if ((e1 == null) || (e1.equals(""))) {
        // plain-text message
        errors.add("The custom1 field must be filled out in order to complete this item.");
    }

    if ((e2 == null) || (e2.equals(""))) {
        // key for the message in the messages catalog
        errors.add("custom2_missing_info");
    }

    if (scale == null) {
        // key for the message in the messages catalog, plus message arguments
        List list = new ArrayList();
        list.add("err_missing_custom_cert_info");
        list.add(entity.getIdentity());
        list.add(entity.getType());
        errors.add(list);
    }

    if ("shave".equals(e1) && "haircut".equals(e2) && "bits".equals(scale) &&
        (2 != cost)) {
        // can't do this b/c beanShell doesn't support the Java5 elements in the Message object
        errors.add(new Message(Message.Type.Error, MessageKeys.ERROR_SHAVE_HAIRCUT_PRICE));
    }

    return errors;
    ]]>
  </Source>
</Rule>


<Rule language="beanshell" name="Example Certification Entity Refresh Rule"
      type="CertificationEntityRefresh">
  <Description>
   A CertificationEntity refresh rule is run when a CertificationEntity is
   refreshed.  For example, this can copy a custom field from the
   CertificationEntity down onto all sub-items.
  </Description>
  <Signature returnType="String">
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification being refreshed.
        </Description>
      </Argument>
      <Argument name="entity">
        <Description>
          The sailpoint.object.CertificationEntity being refreshed.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.CertificationItem;

    String custom1 = entity.getCustom1();
    String custom2 = entity.getCustom2();
    Map customMap = entity.getCustomMap();

    if (null != entity.getItems()) {
        for (Iterator it=entity.getItems().iterator(); it.hasNext(); ) {
            CertificationItem item = (CertificationItem) it.next();
            item.setCustom1(custom1);
            item.setCustom2(custom2);
            item.setCustomMap(customMap);
        }
    }
    ]]>
  </Source>
</Rule>


<Rule language="beanshell" name="Example Certification Sign Off Approver Rule" type="CertificationSignOffApprover">
  <Description>
   This rule is run when the certification is signed off to determine who
   (if anyone) needs to approve the certification decisions.  If this returns
   a non-null identity, the certification is forwarded to the returned identity.
  </Description>
  <Signature returnType="Map">
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification that was signed.
        </Description>
      </Argument>
      <Argument name="certifier">
        <Description>
          The sailpoint.object.Identity that signed the certification.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identityName'>
        <Description>
        The name of the Identity that should approve the certification.  Either
        this or 'identity' should be non-null if certification sign off approval
        is desired.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
        The Identity that should approve the certification.  Either this or
        'identityName' should be non-null if certification sign off approval
        is desired.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Identity;

    // This requires approval all the up the manager hierarchy.  Once we get to
    // the most senior manager, approvals stop.
    Identity identity = certifier.getManager();

    Map results = new HashMap();
    results.put("identity", identity);
    return results;
    ]]>
  </Source>
</Rule>

<Rule language="beanshell" name="Example Certification Event Rule" type="IdentityTrigger">
  <Description>
  This rule can be used for Certification Events that use rule triggers.
  The previousIdentity and newIdentity hold a snapshot of the identity before
  the update has occurred and the current state of the identity (after the
  update), respectively.  In this example, we create a new certification for
  the identity if the composite risk score goes over a threshold of 700.
  </Description>
  <Signature returnType="boolean">
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext.
        </Description>
      </Argument>
      <Argument name="previousIdentity">
        <Description>
          The identity before the refresh/aggregation (this will be null when an
          identity is created).
        </Description>
      </Argument>
      <Argument name="newIdentity">
        <Description>
          The identity after the refresh/aggregation (this will be null when an
          identity is deleted).
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
    // Make sure that this is a modification.
    if ((void == previousIdentity) || (void == newIdentity)) {
        return false;
    }

    int threshold = 700;
    int oldScore = 0;
    int newScore = 0;

    if (null != previousIdentity.getScorecard()) {
        oldScore = previousIdentity.getScorecard().getCompositeScore();
    }
    if (null != newIdentity.getScorecard()) {
        newScore = newIdentity.getScorecard().getCompositeScore();
    }

    // Return true if the old score was under the threshold and the new
    // score has exceeded the threshold.
    return ((oldScore < threshold) && (newScore >= threshold));
    ]]>
  </Source>
</Rule>

<Rule name="Example Scope Correlation Rule" language="beanshell" type="ScopeCorrelation">
  <Description>
    Given an identity and the defined scope correlation attribute and value,
    determine the correct assigned scope for the Identity.  This can return a
    single Scope (if we can correlate to a distinct scope), a List of Scopes (if
    we can't determine a distinct scope), or null (if there is not an assigned
    scope for the given identity).
  </Description>
  <Signature returnType='Object'>
    <Inputs>
      <Argument name='identity'>
        <Description>
          The identity for which to correlate the assigned scope.
        </Description>
      </Argument>
      <Argument name='scopeCorrelationAttribute'>
        <Description>
          The name of the scope correlation attribute on the identity.
        </Description>
      </Argument>
      <Argument name='scopeCorrelationAttributeValue'>
        <Description>
          The value of the scope correlation attribute on the given identity.
        </Description>
      </Argument>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in correlation.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='scopes'>
        <Description>
          Either a Scope or a List that contains multiple scopes that could
          correlate to the given identity.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Scope;

    List scopes = new ArrayList();
    if (scopeCorrelationAttributeValue != void) {
        Scope scope = context.getObjectByName(Scope.class,
                                              scopeCorrelationAttributeValue);
        if (null != scope)  scopes.add(scope);
    }
    return scopes;
    ]]>
  </Source>
</Rule>

<Rule name="Example Scope Selection Rule" language="beanshell" type="ScopeSelection">
  <Description>
    This rule is run if scope correlation for an identity's assigned scope (either
    from a scope correlation attribute or rule) returns a list of scopes because
    the correlation is ambiguous.  This can happen since scopes are not guaranteed
    to have unique names.  This rule is responsible for selecting the correct
    scope out of the candidateScopes list for the given identity.  If the correct
    scope cannot be determined, this rule should return null.
  </Description>
  <Signature returnType='Scope'>
    <Inputs>
      <Argument name='identity'>
        <Description>
          The identity for which to correlate the assigned scope.
        </Description>
      </Argument>
      <Argument name='scopeCorrelationAttribute'>
        <Description>
          The name of the scope correlation attribute on the identity.
        </Description>
      </Argument>
      <Argument name='scopeCorrelationAttributeValue'>
        <Description>
          The value of the scope correlation attribute on the given identity.
        </Description>
      </Argument>
      <Argument name='candidateScopes'>
        <Description>
          The List of scopes that were correlated to the given Identity.  A
          single Scope from this list should be selected and returned if it is
          possible to determine the correct scope.
        </Description>
      </Argument>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in selection.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='scope'>
        <Description>
          A single scope selected from the candidateScopes List, or null if it
          is impossible to determine the correct scope for the given identity.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
    import sailpoint.object.Scope;

    Scope selected = null;

    // Use the identity's deparment to select the correct subscope.
    String dept = identity.getAttribute("department");
    if (null != dept) {
        for (Iterator it=candidateScopes.iterator(); it.hasNext(); ) {
            Scope current = (Scope) it.next();

            // If any of the ancestor scopes have this user's department name,
            // then use it.
            Scope parent = null;
            while (null != (parent = current.getParent())) {
                if (dept.equals(parent.getName())) {
                    selected = current;
                    break;
                }
            }
        }
    }

    return selected;
    ]]>
  </Source>
</Rule>

<!--
   Example Delimited File PreIterate rule. This rule is called before the
   connector processes the data in a file.
 -->
<Rule name="Example PreIterate Rule" type="PreIterate">
  <Description>
     An example Preiterate rule for the DelimitedFileConnector that
     can check stats of the file being processed against stats
     collected and persisted during the last aggregation
     in the PostIterate rule.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application being iterated.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being iterated
        </Description>
      </Argument>
      <Argument name='stats'>
        <Description>
          A map passed by the connector of the stats for the file about to be iterated.
          Contains keys:
            fileName : (String) filename of the file about to be processed
            absolutePath : (String) absolute filename
            length : (Long) length in bytes
            lastModified : (Long) last time the file was updated Java GMT
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.xml.XMLObjectFactory;
      import sailpoint.object.Configuration;

      SailPointContext ctx = SailPointFactory.getCurrentContext();
      if ( ctx == null ) {
          throw new GeneralException("Unable to get sailpoint context.");
      }

      String name = application.getName() + "_aggregationStats";
      Configuration config = ctx.getObject(Configuration.class,name);
      // The existance of a config object means the post rule
      // has created an object and the stats should be checked
      if ( config != null ) {
          if ( log.isDebugEnabled() ) {
              log.debug("CurrentStats: \n" + XMLObjectFactory.getInstance().toXml(stats));
              log.debug("Config : \n" + config.toXml());
          }
          String key = schema.getObjectType();
          Map lastStats = (Map)config.get(key);
          if ( lastStats != null ) {
              Long lastMod = (Long)lastStats.get("lastModified");
              Long currentMod = (Long)stats.get("lastModified");
              if ( currentMod < lastMod ) {
                  throw new GeneralException("Last modification date is older then it was during the last aggregation!");
              }

              // This probably isn't real world (the size could decrease without a problem)
              // I'm including it here for illustration
              Long currentLength = (Long)stats.get("length");
              Long lastLength = (Long)lastStats.get("length");
              if ( currentLength > lastLength ) {
                  throw new GeneralException("The data file's length is less then it was during the last aggregation!");
              }
          } else {
              if ( log.isDebugEnabled() ) {
                  log.debug("Configuration for ["+key+"] was not found...Nothing checked.");
              }
          }
      } else {
          if ( log.isDebugEnabled() ) {
              log.debug("Configuration ["+name+"] was not found...Nothing checked.");
          }
      }
    ]]>
  </Source>
</Rule>

<!--

 -->
<Rule name="Example PostIterate Rule" type="PostIterate">
  <Description>
    An example PostIterate rule that can be configured
    on a DelimitedFileConnector.

    This rule add stats to a Configuration object and persists
    it with a well-known name that will be checked by the
    PreIterate rule during the next run for file integrity.

    The Configuration object created by this rule contains
    a key for each schema type so we can have a single object
    for each application.

    Stats is a Map passed in by the connector with the information
    it has gathered. Custom keys can be added here if necessary for
    for validation.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application being iterated
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema requested during iteration
        </Description>
      </Argument>
      <Argument name='stats'>
        <Description>
          A map of the stats for the current file that was just iterated.
          Contains keys:
            fileName : (String) filename of the file about to be processed
            absolutePath : (String) absolute filename
            length : (Long) length in bytes
            lastModified : (Long) last time the file was updated Java GMT
            columnNames : (List) column names that were used during the iteration
            objectsIterated : (Long) total number of objects iterated during this run
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.api.SailPointFactory;
      import sailpoint.api.SailPointContext;
      import sailpoint.tools.GeneralException;
      import sailpoint.object.Configuration;
      import sailpoint.object.Attributes;

      SailPointContext ctx = SailPointFactory.getCurrentContext();
      if ( ctx == null ) {
          throw new GeneralException("Unable to get sailpoint context.");
      }

      String name = application.getName() + "_aggregationStats";
      Configuration config = ctx.getObject(Configuration.class,name);
      if ( config == null ) {
          if ( log.isDebugEnabled() ) {
              log.debug("Configuration ["+name+"] was not found creating new one.");
          }
          config = new Configuration();
          config.setName(name);
      }

      Attributes attrs = config.getAttributes();
      if ( attrs == null ) attrs = new Attributes();

      String key = schema.getObjectType();
      attrs.put(key, stats);
      config.setAttributes(attrs);
      if ( log.isDebugEnabled() ) {
          log.debug("Newly created Configuration object :\n"+ config.toXml());
      }
      ctx.saveObject(config);
      ctx.commitTransaction();
    ]]>
  </Source>
</Rule>

<!--
   Example JDBC Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="Example JDBC Provisioning Rule" type="JDBCProvision">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     deletes the Account(s) from the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.util.*;
	import java.sql.SQLException;
	import sailpoint.object.ProvisioningResult;
	import sailpoint.object.ProvisioningPlan.AccountRequest;
	
	List  accounts = plan.getAccountRequests();
	System.out.println("string is " + plan.toXml());
	System.out.println("before for loop");
	ProvisioningResult provResult = new ProvisioningResult();
	if(accounts.size() > 0) {
    	for(int i = 0; i < accounts.size(); i++) {
			AccountRequest temp = accounts.get(i);
       		System.out.println(temp.getApplication());
      		AccountRequest.Operation op = temp.getOperation();            
        	String accountId = temp.getNativeIdentity();
    		System.out.println("identity  " + accountId);
			System.out.println("operation " + op);
			try {
			    stmt = connection.createStatement(); 
                // creating Query String   
                String query = "DELETE FROM USER WHERE FIRSTNAME='" + accountId + "'";     
 			    System.out.println("query is  " + query);               
                stmt.executeUpdate(query);
            }
			catch(SQLException e) {     
  				provResult.setStatus(ProvisioningResult.STATUS_FAILED);
                provResult.addError(e);
			}
    	}
	}
	
	System.out.println("after the for loop");
	return provResult ;
    ]]>
  </Source>
</Rule>
<!--
   Example JDBC Enable Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Enable Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     enables the Account(s) in the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.sql.*;
import java.sql.Statement;
import sailpoint.object.ProvisioningResult;  
 ProvisioningResult result = new ProvisioningResult();
 result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
 Statement stmt=null;
 String user = request.getNativeIdentity();           
  try{
      String query = "UPDATE openconntest.accounts SET isrevoked='N' where userid='" + user + "'";
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);   
    }finally{
	if(stmt!=null)
	    stmt.close();
	}
	return result;
    ]]>
  </Source>
</Rule>


<!--
   Example JDBC Disable Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Disable Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     disables the Account(s) in the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.sql.*;
    import java.sql.Statement;
    import sailpoint.object.ProvisioningResult;  
    ProvisioningResult result = new ProvisioningResult();
    result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
    Statement stmt=null;
    String user = request.getNativeIdentity();           
  try{
      String query = "UPDATE openconntest.accounts SET isrevoked='Y' where userid='" + user + "'";
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);   
    }finally{
	if(stmt!=null)
	    stmt.close();
	}
	return result;
    ]]>
  </Source>
</Rule>

<!--
   Example JDBC Delete Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Delete Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     deletes the Account(s) from the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.sql.*;
import java.sql.Statement;
import sailpoint.object.ProvisioningResult;  
 ProvisioningResult result = new ProvisioningResult();
 result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
 Statement stmt=null;
 String user = request.getNativeIdentity();           
  try{
       String  query = "delete from openconntest.accounts where userid='" + user + "'";     
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);   
    }finally{
	if(stmt != null)
	    stmt.close();
	}
	return result;
    ]]>
  </Source>
</Rule>
<!--
   Example JDBC Unlock Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Unlock Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     unlocks the Account(s) in the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.sql.*;
import java.sql.Statement;
import sailpoint.object.ProvisioningResult;  
 ProvisioningResult result = new ProvisioningResult();
 result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
 Statement stmt=null;
 String user = request.getNativeIdentity();           
  try{
      String query = "UPDATE openconntest.accounts SET islock='N' where userid='" + user + "'";
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);   
    }finally{
	if(stmt!=null)
	    stmt.close();
	}
	return result;
    ]]>
  </Source>
</Rule>

<!--
   Example JDBC Create Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Create Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     creates the Account(s) in the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
import java.sql.*;
import java.sql.Statement;
import sailpoint.object.ProvisioningResult;  
 ProvisioningResult result = new ProvisioningResult();
 result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
 Statement stmt=null;
 String user = request.getNativeIdentity();           
  try{
       /*
         From the request get all the attribute request
         Populate the hashmap and extract data from hashmap and form the query accordingly.
       */
       String query = "INSERT INTO openconntest.accounts(userid,firstname,lastname,email,password,islock,isrevoked) values ('"+user+"','Mango','Mood','abc1234@sailpoint.com','Sailpoint123','N','N')";       
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);
      }finally{
	if(stmt != null)
	    stmt.close();
	}
	return result;
	
    ]]>
  </Source>
</Rule>

<!--
   Example JDBC Modify Provisioning rule. This rule is called when the
   connector needs to provision the Account(s) data in the database.
 -->
<Rule name="JDBC Modify Provision Rule" type="JDBCOperationProvisioning">
  <Description>
     An example Provisioning rule for the JDBC Connector that
     modify the Account(s) in the database.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          query the database to aid in provisioning.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application the account is being provisioned for.
        </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          Schema representing the data being provisioned.
        </Description>
      </Argument>
      <Argument name='connection'>
        <Description>
          Connection to the application database.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the application.
        </Description>
      </Argument>
      <Argument name='log'>
        <Description>
          log for debugging
        </Description>
      </Argument>
       <Argument name='request'>
        <Description>
        request for specific operation
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
	import java.sql.*;
import java.sql.Statement;
import sailpoint.object.ProvisioningResult;  
 ProvisioningResult result = new ProvisioningResult();
 result.setStatus(ProvisioningResult.STATUS_COMMITTED); 
 Statement stmt=null;
 String user = request.getNativeIdentity();  
  try{
       String query = "UPDATE openconntest.accounts SET firstname='AMOL',lastname='CHAUDHARI',email='amol.changed@sailpoint.com' where userid='"+user+"'";       
        stmt = connection.createStatement();
        stmt.execute(query);
	 }catch(Exception e){
	    result.addError(e.getMessage());
        result.setStatus(ProvisioningResult.STATUS_FAILED);   
    }finally{
	    stmt.close();
	}
	return result;
    ]]>
  </Source>
</Rule>
<Rule name='Render SOD Entitlements' type='Violation'>
<Description>

An example rendering rule that will generate a multi-line
string containing details of the entitlements involved in
a polcy violation.  This may be used for both Role SOD policies
and Entitlement SOD policies.

sailpoint.api.PolicyUtil does most of the work, we render
the resulting EntitlementSummary.

EntitlementSummary is an object with two lists one for the "left"
side and one for the "right".  Due to space limitations in
description table cells we'll render the left on top and right on the
bottom seperated by a line of text "--- conflicts with ---".

</Description>
<Source>
  import java.util.List;
  import sailpoint.api.PolicyUtil;
  import sailpoint.api.PolicyUtil.EntitlementSummary;
  import sailpoint.api.PolicyUtil.RoleSummary;
  import sailpoint.api.PolicyUtil.ApplicationSummary;
  import sailpoint.api.PolicyUtil.ItemSummary;

  private summarizeApp(StringBuilder b, ApplicationSummary app) {
      List atts = app.attributes;
      if (atts != null &amp;&amp; atts.size() > 0) {
          b.append(app.name);
          b.append(": ");
          for (int i = 0 ; i &lt; atts.size() ; i++) {
              ItemSummary as = atts.get(i);
              if (i > 0) b.append(" ");
              b.append(as.name);
              b.append("=");
              List values = as.values;
              if (values == null) {
                  b.append("null");
              }
              else if (values.size() > 1) {
                  // this will bracket it with []
                  b.append(values.toString());
              }
              else if(values.size() == 1){
                  b.append("'");
                  b.append(values.get(0).toString());
                  b.append("'");
              }
          }
          b.append(" ");
      }

      // let's put permissions each on a line since they
      // tend to be larger than attribute values?
      List perms = app.permissions;
      if (perms != null &amp;&amp; perms.size() > 0) {
          for (int i = 0 ; i &lt; perms.size() ; i++) {
              ItemSummary ps = perms.get(i);

              b.append(app.name);
              b.append(": ");

              List values = ps.values;
              if (values == null) {
                  b.append("none");
              }
              else if (values.size() > 1) {
                  // this will bracket it with []
                  b.append(values.toString());
              }
              else {
                  b.append("'");
                  b.append(values.get(i).toString());
                  b.append("'");
              }

              b.append(" on ");
              b.append(ps.name);
              b.append(" ");
          }
      }

  }

  private summarizeRole(StringBuilder b, RoleSummary role) {
      // you won't have a role name for Entitlement SOD
      if (role.name != null) {
          b.append("Role: ");
          b.append(role.name);
          b.append(" ");
      }
      List apps = role.applications;
      if (apps != null) {
          for (int i = 0 ; i &lt; apps.size() ; i++)
              summarizeApp(b, apps.get(i));
      }
  }

  private summarizeRoles(StringBuilder b, List roles) {
      // in practice there will only be one role
      if (roles != null) {
          for (int i = 0 ; i &lt; roles.size() ; i++) {
              summarizeRole(b, roles.get(i));
          }
      }
  }

  // here is where the model is built
  EntitlementSummary summary =
    PolicyUtil.summarizeViolationEntitlements(context, identity,
                                              violation, null);

  if (summary != null) {
      StringBuilder b = new StringBuilder();
      summarizeRoles(b, summary.left);
      b.append("--- conflicts with --- ");
      summarizeRoles(b, summary.right);
      violation.setDescription(b.toString());
  }
</Source>
</Rule>

<!--
  An example CompositeRemediation rule that is called  when provisioning
  needs to be performed against composite accounts.
 -->
<Rule language='beanshell' name='Example Composite Remediation Rule'
      type='CompositeRemediation'>

  <Description>
    A example rule that is called when provisioning is about to be performed
    against a composite connector.  The rule needs to convert the
    provisioning plan built up for the composite connector into a
    plan that will target the applications that make up the
    composite application.

    In this example we have a composite rule for an application named
    FinanceDemo that is made up of two "tiers" a db application named
    OracleDB and an LDAP application named CorpDirectory.

    The entitlements of the composite accounts all come from the
    "groups" attribute on the CorpDirectory application which maps to the
    "groupMember" attribute on the FinanceDemo application.

    This rule will look through the AccountRequest for the FinanceDemo
    application sifting through the attribute requests looking for
    requests that target the groupMember attribute covert them to
    target the groups attribute on the CorpDirectory application.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='identity'>
        <Description>
           The Identity object that is going to be remediated.
        </Description>
      </Argument>
      <Argument name='plan'>
        <Description>
          The ProvisioningPlan created against the composite application.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='provisioningPlan'>
        <Description>
          A converted provisioning plan that targets the applications
          that make up the composite application.
        </Description>
      </Argument>
    </Returns>
  </Signature>

  <Source>
    <![CDATA[
      import sailpoint.tools.GeneralException;
      import sailpoint.tools.Util;
      import sailpoint.object.Identity;
      import sailpoint.object.ProvisioningPlan;
      import sailpoint.object.ProvisioningPlan.AccountRequest;
      import sailpoint.object.ProvisioningPlan.AttributeRequest;

      ProvisioningPlan updatedPlan = null;
      if ( plan != null ) {
          // Get the account request for the composite application from the plan by app name
          AccountRequest compositeRequest = plan.getAccountRequest("FinanceDemo");
          if ( compositeRequest != null ) {
              List convertedAttributeRequests = new ArrayList();
              // Convert the attribute requests that refrence groupMember to just groups
              List attributeRequests = compositeRequest.getAttributeRequests();
              if ( Util.size(attributeRequests) > 0 ) {
                  for ( AttributeRequest request : attributeRequests ) {
                      String attributeName = request.getName();
                      if ( "groupMember".compareTo(attributeName) == 0 ) {
                          AttributeRequest req = new AttributeRequest(request);
                          req.setName("groups");
                          convertedAttributeRequests.add(req);
                      } else {
                          convertedAttributeRequests.add(new AttributeRequest(req));
                      }
                  }
              }

              List updatedAccountRequests = new ArrayList();

              // add in any other request that are part of the plan if any
              List accountRequests = plan.getAccountRequests();
              if ( Util.size(accountRequests) > 0 ) {
                  for ( AccountRequest accountRequest : accountRequests) {
                      String appName = accountRequest.getApplication();
                      if ( "FinanceDemo".compareTo(appName) != 0 ) {
                          updatedAccountRequests.add(accountRequest);
                      }
                  }
              }

              // Convert the "FinanceDemo" request to "CorpDirectory" and add it
              // to the updated account requests
              AccountRequest convertedRequest = new AccountRequest(compositeRequest);
              convertedRequest.setApplication("CorporateDirectory");
              convertedRequest.setAttributeRequests(convertedAttributeRequests);
              updatedAccountRequests.add(convertedRequest);

              // build up the new plan based on the old plan the converted account request
              // for the composite application
              updatedPlan = new ProvisioningPlan(plan);
              updatedPlan.setAccountRequests(updatedAccountRequests);
          }
      }
      return updatedPlan;
    ]]>
  </Source>
</Rule>

<!--
  -  An example rule that can be called to generate an Identities
  -  displayName during attribute promotion.
  -  This rule should always return a non-null value
  -  because it's may be used in display grids.
  -
  -  Attempt to use the fullname, if its null
  -  then use the identiies name which is guarenteed to
  -  be non-null.
-->
<Rule name="Example Identity Display Name Generation Rule" type="IdentityAttribute">
  <Description>
    Example rule that can be used to generate an identity's displayName during attribute promotion.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='environment' type='Map'>
        <Description>
           Arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
           The Identity object that represents the user
           that is being aggregated.
        </Description>
      </Argument>
      <Argument name='attributeDefinition'>
        <Description>
           The AttributeDefinition object for this attribute.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='attributeValue'>
        <Description>
          The value of the attribute that should be populated.
          The rule should return this value.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      String displayName = null;
      String fullName = identity.getFullName();
      if ( Util.getString(fullName) != null ) {
          displayName = fullName;
      } else {
          displayName = identity.getName();
      }
      return displayName;
    ]]>
  </Source>
</Rule>


<Rule name="Example Create Account Name" type="FieldValue">
  <Description>
    Example rule that can be used to generate an account name for an identity
    when creating a new account.

    Attempt to use the fullname. If it's null, then use the identity's name,
    which is guaranteed to be non-null.
  </Description>
  <Signature returnType='String'>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='identity'>
        <Description>
           The Identity object that represents the user
           that the account is being created for.
        </Description>
      </Argument>
      <Argument name='accountRequest'>
        <Description>
           The account request within the provisioning plan that is being compiled.
        </Description>
      </Argument>
      <Argument name='field'>
        <Description>
           The field within the provisioning policy that is being processed.
        </Description>
      </Argument>
      <Argument name='[field values]'>
        <Description>
           This is not the name of an actual argument.  It means that the values
           of all fields that appear before this field will be included as
           arguments.  The names of the arguments will be the names of the
           previous fields.
        </Description>
      </Argument>
      <Argument name='[workflow arguments]'>
        <Description>
           This is not the name of an actual argument.  It means that when the
           field is being processed within a workflow, the values of the
           step arguments will be passed as arguments to any rules or scripts
           evaluated within the step.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='accountName'>
        <Description>
          The string value of the new account name (first initial and last name).
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      String accountName = null;
      String firstName = identity.getFirstname();
      String lastName = identity.getLastname();
      if(firstName !=null && lastName!=null) {
        accountName = new String(firstName.charAt(0) + lastName);
      }
      return accountName;
    ]]>
  </Source>
</Rule>

<Rule name='Policy Violation Owner Rule' language='beanshell'
      type='IdentitySelector'>
  <Description>
  An example rule that can be called to assign a default owner for a policy violation.
  </Description>
  <Signature returnType='Identity'>
    <Inputs>
      <Argument name='context'>
        <Description>
          A sailpoint.api.SailPointContext object that can be used to
          access the database.
        </Description>
      </Argument>
      <Argument name='identity' type='Identity' required='true'>
        <Description>
          The identity that is the violator.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[

    import sailpoint.object.Identity;

    return context.getObjectByName(Identity.class, "spadmin");

    ]]>
  </Source>
</Rule>

<Rule language='beanshell' type='EmailRecipient' name='Example Email Recipient Rule'>
  <Description>
      This rule is used to select an identity or a list of identities who will receive email.
      In this case the manager of work item owner is selected to be notified.
  </Description>
  <Signature returnType='String or List of Strings'>
    <Inputs>
      <Argument name='item'>
        <Description>
          The sailpoint.object.Notifiable Interface for objects that can be reminded, escalated, and expired. 
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identity name or names'>
        <Description>
        You can return an identity name or a list of identity names.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[

    return item.getOwner().getManager().getName();

    ]]>
  </Source>
</Rule>

<!--
  -  An example SAP buildMap rule that can be used to customize
  -  the SAP object that our connectors build by default.
  -
  -  This rule is called before we construct the ResourceObject
  -  from the Map object we've assembled by calling the various
  -  BAPI functions.
  -
  -  The rule can use any of the JCO objects, but for this example we call
  -  to some helper methods on the connector to make the code a bit more
  -  manageable and readable.
  -
  -  This rule is different from a Customization rule in that you're dealing
  -  with a Map vs ResourceObject and this rule also gets a "destination" object
  -  so it can make SAP calls to build up extra data. This rule is very much
  -  like a BuildMap rule from the DelimitedFileConnector, but gets an already
  -  built object.
  -
-->
<Rule name='Example SAP BuildMap calling a BAPI Function Module'
      language='beanshell' type='SAPBuildMap'>

  <Description>
     This is an example of a buildMap rule for SAP that uses a BAPI call to
     add additional information to the ResourceObjects built by the default
     SAP Connector implementation.

     The rule gets a Map named 'object' that holds all of the attributes
     we've built up using the default SAP implementation.  The object can
     be modified/added to here to help support customer customizations and
     transformations that require the SAP system.

     In this example rule we call the BAPI_USER_GET_DETAIL function module
     and adorn the LASTMODIFIED attributes to our object because they are
     not part of the base implementation.
  </Description>

  <Signature>
    <Inputs>
      <Argument name='destination'>
        <Description>
          A connected/ready to use com.sap.conn.jco.JCoDestination object that can
          be used to call bapi, function modules and call to SAP tables. This
          is the main object used in making BAPI calls using the JCo interface.
          This destination object is shared with the connector implementation and the
          connector controls the destination's lifecycle.
         </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          The schema that represents the object we are building.
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
         The SAP connector that is being used to communicate with SAP.
         This class is here for convenience as there are many utility methods
         that make calling Function Modules and doing table lookup easier
         </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The SAP application object being used to connect to the SAP system.
        </Description>
      </Argument>
      <Argument name='state'>
        <Description>
          A map object that can be used to store data during the iteration process.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          A map object that holds the attributes that have been built up by the
          default connector implementation. Any attributes built by this rule
          should be added to this object. This object is handed by reference,
          so it can be used directly.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
      import com.sap.conn.jco.JCoDestination;
      import com.sap.conn.jco.JCoException;
      import com.sap.conn.jco.JCoFunction;
      import com.sap.conn.jco.JCoParameterList;
      import com.sap.conn.jco.JCoRecordField;
      import com.sap.conn.jco.JCoRecordFieldIterator;
      import com.sap.conn.jco.JCoStructure;
      import com.sap.conn.jco.JCoTable;

      import sailpoint.connector.Connector;
      import sailpoint.connector.SAPConnector;
      import sailpoint.tools.xml.XMLObjectFactory;

      if ( !Connector.TYPE_ACCOUNT.equals(schema.getObjectType()) ) {
          // this example is specific to the account type so just return
          // for group aggregations
          return;
      }

      // First get a JCoFunction object, this will throw if there are issues resolving
      // the function module/BAPI function
      JCoFunction getDetail = connector.getFunction(destination, "BAPI_USER_GET_DETAIL");

      String id = object.getString("User Name");
//System.out.println("Customizing ["+id+"]");

      // Next fill out the parameters that are necessary to execute the funciton
      // in this case is the username for the user we want the details collected
      getDetail.getImportParameterList().setValue(SAPConnector.ATTR_USERNAME, id);

      // Next fill out which of the resulting tables/structures we want to be
      // returned when the function is executed. ALL results are ON by default
      // so anything we aren't interested in has to be disabled
      // this stuff can be skipped if you want EVERYTHING the BAPI returns.
      // NOTE: The less data we return the more efficient the call is.
      getDetail.getExportParameterList().setActive("ISLOCKED", false);

      // Next, execute the function and check for exceptions
      getDetail.execute(destination);
      connector.checkForExceptions(getDetail);

      // After the function has been executed, get the structure that holds the data you are
      // trying to adorn.
      JCoStructure lastModifiedData = getDetail.getExportParameterList().getStructure("LASTMODIFIED");

      // turn the JCO structure into a map then adorn the data to the object
      // that has already been built by the default connector implementation
      Map lastModifiedAttrs = connector.buildAttributesFromStructure(lastModifiedData);
      if ( lastModifiedAttrs != null ) {
          //
          // This will add two new attributes they will be named MODDATE and MODTIME
          // as those are the default names returned from the JCO side.
          //
          // The names can be changed here just make sure the Schema includes any new
          // attributes added to the object or they will be filtered out of the
          // attributes when we build a ResourceObject later in the process
          //
          // For MODDATE and MODTIME to show up in Links returned from SAP they both
          // must be added to the application's account schema.
          //
          object.putAll(lastModifiedAttrs);
      }
//System.out.println("Resulting object ["+XMLObjectFactory.getInstance().toXml(object)+"]");
    ]]>
  </Source>
</Rule>

<!--
  -  An example SAP buildMap rule that can be used to customize
  -  the SAP object that our connectors build by default.
  -
  -  This rule is called before we construct the ResourceObject
  -  from the Map object we've assembled by calling the various
  -  BAPI functions.
  -
  -  This rule is different from a Customization rule in that you're dealing
  -  with a Map vs ResourceObject and this rule also gets a "destination" object
  -  so it can make sap calls to build up extra data. This rule is very much
  -  like a BuildMap rule from the DelimitedFileConnector, but gets an already
  -  built object.
  -
  -  The rule can use any of the JCO objects, but for this example we call
  -  to some helper methods on the connector to make the code a bit more
  -  manageable and readable.
  -
  -  This rule calls a BAPI Function Module to adorn additional
  -  data to an account object.
  -
-->
<Rule name='Example SAP BuildMap calling a BAPI to Query an SAP table'
      language='beanshell' type='SAPBuildMap'>

  <Description>
     This is an example of a buildMap rule for SAP that uses a BAPI call to
     add additional information to the ResourceObjects built by the default
     SAP Connector implementation.

     The rule gets a Map named 'object' that holds all of the attributes
     we've built up using the default SAP implementation.  The object can
     be modified/added to here to help support customer customizations and
     transformations that require the SAP system.

     In this example rule we call to the ARG_TEXTS table to get the long
     description for a role object during group aggregation. By default
     the connector puts this value in a multi-valued "Long Description"
     field, but here we concatenate all of the lines together into a single
     value and put it in the Description field.
  </Description>

  <Signature>
    <Inputs>
      <Argument name='destination'>
        <Description>
          A connected/ready to use com.sap.conn.jco.JCoDestination object that can
          be used to call bapi, function modules and call to SAP tables. This
          is the main object used in making BAPI calls using the JCo interface.
          This destination object is shared with the connector implementation and the
          connector controls the destination's lifecycle.
         </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          The schema that represents the object we are building.
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
         The SAP connector that is being used to communicate with SAP.
         This class is here for convenience as there are many utility methods
         that make calling Function Modules and doing table lookup easier
         </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The SAP application object being used to connect to the SAP system.
        </Description>
      </Argument>
      <Argument name='state'>
        <Description>
          A map object that can be used to store data during the iteration process.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          A map object that holds the attributes that have been built up by the
          default connector implementation. Any attributes built by this rule
          should be added to this object. This object is handed by reference,
          so it can be used directly.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
      import com.sap.conn.jco.JCoDestination;
      import com.sap.conn.jco.JCoException;
      import com.sap.conn.jco.JCoFunction;
      import com.sap.conn.jco.JCoParameterList;
      import com.sap.conn.jco.JCoRecordField;
      import com.sap.conn.jco.JCoRecordFieldIterator;
      import com.sap.conn.jco.JCoStructure;
      import com.sap.conn.jco.JCoTable;

      import sailpoint.connector.Connector;
      import sailpoint.connector.SAPConnector;
      import sailpoint.tools.xml.XMLObjectFactory;
      import sailpoint.tools.Util;

      if ( !Connector.TYPE_GROUP.equals(schema.getObjectType()) ) {
          // this example is specific to the group type when building
          // account groups for the Role objects in SAP
          return;
      }

      String id = object.getString("Name");
      // build a list of the fields we want returned from the table
      // the "select" part of the query
      List fields = new ArrayList();
      fields.add("TEXT");

      // Build up the conditions that will be used to query the table
      // In this case AGR_NAME (roleName) is equal to our roleName
      // AND the SPRAS flag is set to E.
      List conditions = new ArrayList();
      conditions.add("AGR_NAME = '"+id+"'");
      conditions.add("SPRAS = 'E'");

      // Make the query and get back the result
      // This helper method calls RFC_READ_TABLE and builds the query then extracts the result
      // This method is helpful when you want to get back a single column from a table
      // more complex queries will need to call RFC_READ_TABLE directly
      //
      // In this query we are querying the ARG_TEXTS table, querying by nameand requesting
      // one field named TEXT.  TEXT holds the long description for each role.
      // The last parameter is they key should be used to get each value from the row returned
      // from RFC_READ_TABLE
      //
      List lines = connector.querySAPTable(destination, "AGR_TEXTS", conditions, fields, "DATA");
      if ( Util.size(lines) > 0  ) {
          // Take the lines and build just a single string
          StringBuffer sb = new StringBuffer();
          for ( int i=0; i<lines.size(); i++ ) {
              String line = (String)lines.get(i);
              if ( Util.getString(line) == null )
                 line = " ";

              sb.append(line);
          }
          if ( sb.length() > 0 ) {
              object.put(SAPConnector.ATTR_DESCRIPTION, sb.toString());
              object.remove(SAPConnector.ATTR_LONG_DESCRIPTION);
          }
      }
//System.out.println("Resulting object ["+XMLObjectFactory.getInstance().toXml(object)+"]");
    ]]>
  </Source>
</Rule>


<Rule language='beanshell' type='ManagedAttributePromotion' name='Example Managed Attribute Promotion Rule'>
  <Description>
    A ManagedAttributePromotion rule is called when ManagedAttributes are automatically created during aggregation, refresh, or from the missing entitlement descriptions task.

    This can modify the ManagedAttribute that is passed in to set fields such as owner, requestable, or explanations before they are saved.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='attribute'>
        <Description>
          The sailpoint.object.ManagedAttribute being promoted.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The sailpoint.object.Application the managed attribute is from.
        </Description>
      </Argument>
      <Argument name='state' type='Map'>
        <Description>
          A Map that contains managed attribute customization shared state during a task run.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source><![CDATA[
    import sailpoint.object.*;

    // This doesn't make much sense, but we'll set the owner to the managed of
    // the application owner.
    Identity owner = null;
    if ((null != application) && (null != application.getOwner())) {
        owner = application.getOwner().getManager();
    }
    attribute.setOwner(owner);

    // Make attribute values that start with the letter "A" not requestable.
    String val = attribute.getValue();
    if (val.toUpperCase().charAt(0) == 'A') {
        attribute.setRequestable(false);
    }

    // Here we could look up an description from a file, application, etc...
    String description =
        "Description for " + attribute.getAttribute() + "/" + attribute.getValue();

    // The first parameter is the locale.
    attribute.addDescription("en_US", description);
    ]]>
  </Source>
</Rule>

<Rule name='Example SAP GRC Application Role Query'
      language='beanshell'
      type='SAPBuildMap'>

  <Description>
     This is an example of a buildMap rule for SAP that uses a BAPI call to
     add additional information to the ResourceObjects built by the default
     SAP Connector implementation.

     The rule gets a Map named 'object' that holds all of the attributes
     we've built up using the default SAP implementation.  The object can
     be modified/added to here to help support customer customizations and
     transformations that require the SAP system.

     In this example rule we call to table HRP1852 to get the
     GRC Application Roles assigned to the backend SAP account.
  </Description>

  <Signature>
    <Inputs>
      <Argument name='destination'>
        <Description>
          A connected/ready to use com.sap.conn.jco.JCoDestination object that can
          be used to call bapi, function modules and call to SAP tables. This
          is the main object used in making BAPI calls using the JCo interface.
          This destination object is shared with the connector implementation and the
          connector controls the destination's lifecycle.
         </Description>
      </Argument>
      <Argument name='schema'>
        <Description>
          The schema that represents the object we are building.
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
         The SAP connector that is being used to communicate with SAP.
         This class is here for convenience as there are many utility methods
         that make calling Function Modules and doing table lookup easier
         </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The SAP application object being used to connect to the SAP system.
        </Description>
      </Argument>
      <Argument name='state'>
        <Description>
          A map object that can be used to store data during the iteration process.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          A map object that holds the attributes that have been built up by the
          default connector implementation. Any attributes built by this rule
          should be added to this object. This object is handed by reference,
          so it can be used directly.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
      import java.text.DateFormat;
      import java.text.SimpleDateFormat;

      import sailpoint.connector.Connector;
      import sailpoint.tools.xml.XMLObjectFactory;
      import sailpoint.tools.Util;

      if ( !Connector.TYPE_ACCOUNT.equals(schema.getObjectType()) ) {
          // this example is specific to the backend accounts
          return;
      }

      // The querySAPTable method is helpful when you want to get back a
      // single column from a table more complex queries will need to call
      // RFC_READ_TABLE directly
      //
      // In this query we are querying the HRP1852 for SAP's GRC Application Role mappings.
      // We are querying by name requesting one field named AGR_NAME to be returned.
      //
      // The last parameter is they key should be used to get each value from the row returned
      // from RFC_READ_TABLE which is typically just "DATA".
      //
      // The querySAPTable method returns a list of Strings that includes all the column values
      // returned from the query.

      // build a list of the fields we want returned from the table
      // the "select" part of the query
      List fields = new ArrayList();
      fields.add("ROLE");

      // Build up the conditions that will be used to query the table
      // in this case UNAME (User Name) is equal to our backend
      // account id
      String id = object.getString("User Name");
      List conditions = new ArrayList();
      conditions.add("USERNAME = '"+id+"'");
      // Filter the non active roles
      // These are type BEGDATUM and ENDDATUM format BEGDATUM formatted like 99991231
      Date today = new Date();
      DateFormat dateFormatter =  new SimpleDateFormat("yyyyMMdd");
      dateFormatter.format(new Date());
      conditions.add("BEGDA <= '" + dateFormatter.format(today) + "'");
      conditions.add("ENDDA >= '" + dateFormatter.format(today) + "'");

//System.out.println("About to query Table conditions[" + Util.listToCsv(conditions) +"] Fields["+Util.listToCsv(fields)+"]");

      String tableName = "HRP1852";
      List applicationRoles = connector.querySAPTable(destination, tableName, conditions, fields, "DATA");
      if ( Util.size(applicationRoles) > 0  ) {
          object.put("Application Roles", applicationRoles);
      }

      //
      // Uncomment this line to have the resulting object printed to stdout
      //
//System.out.println("Resulting object ["+XMLObjectFactory.getInstance().toXml(object)+"]");
    ]]>
  </Source>
</Rule>
<Rule language='beanshell' name='Sign Off on End Phase' type='CertificationPhaseChange'>
  <Description>
   When end phase is reached it marks all incomplete items as revoked and signs off on the cer.
  </Description>
  <Signature returnType='void'>
    <Inputs>
      <Argument name='certification'>
        <Description>
          The sailpoint.object.Certification being certified.
        </Description>
      </Argument>
      <Argument name='certificationItem'>
        <Description>
          The sailpoint.object.CertificationItem that is being certified.
        </Description>
      </Argument>
      <Argument name='previousPhase'>
        <Description>
          Certification.Phase (may be null) that is the previous phase.
        </Description>
      </Argument>
      <Argument name='nextPhase'>
        <Description>
          Certification.Phase (may be null) that is the next phase.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
    <![CDATA[
import sailpoint.object.Certification;
import sailpoint.object.CertificationAction;
import sailpoint.object.CertificationEntity;
import sailpoint.object.CertificationItem;
import sailpoint.api.SailPointContext;
import sailpoint.api.Certificationer;
import sailpoint.api.certification.RemediationManager;
import sailpoint.tools.GeneralException;
import sailpoint.tools.Message;
import sailpoint.tools.Util;


    private void rejectUnfinished(CertificationItem certificationItem)
        throws GeneralException {

        List children = certificationItem.getItems();
        if (Util.isEmpty(children)) {
            // a leaf item, must have a status, but only approve if there
            // is not already a decision.
            if ((null == certificationItem.getAction()) || (null == certificationItem.getAction().getStatus())) {
                RemediationManager remedMgr = new RemediationManager(this.context);

                RemediationManager.ProvisioningPlanSummary planSummary = remedMgr.calculateRemediation(certificationItem,
                        CertificationAction.Status.Remediated);

                CertificationAction.RemediationAction remediationAction = planSummary != null ?
                        planSummary.getAction() : null;

                certificationItem.remediate(context, null, null, remediationAction, null, null, null, null, null);
            }
        }
        else {
            // a parent item, does not need a status
            List childItems = certificationItem.getItems();

            if (childItems != null) {
                for (int i=0; i<childItems.size(); ++i) {
                    CertificationItem childItem = (CertificationItem) children.get(i);
                    rejectUnfinished(childItem);
                }
            }
        }
    }

    private void showErrorsIfExists(List errors) {
        if (!Util.isEmpty(errors)) {
            Iterator errorsIterator = errors.iterator();
            while (errorsIterator.hasNext()) {
                Message error = (Message) errorsIterator.next();
                System.out.println(error.getLocalizedMessage());
            }
        }
    }

    private Certification refreshCert(SailPointContext context, Certificationer certificationer, Certification certification)
        throws GeneralException {

        List messages = certificationer.refresh(certification);
        showErrorsIfExists(messages);

        return context.getObjectById(Certification.class, certification.getId());
    }



    List entities = certification.getEntities();
    if (entities != null) {
        Iterator entitiesIterator = entities.iterator();
        while (entitiesIterator.hasNext()) {
            CertificationEntity entity = (CertificationEntity) entitiesIterator.next();
            List items = entity.getItems();
            if (items != null) {
                Iterator itemsIterator = items.iterator();
                while(itemsIterator.hasNext()) {
                    CertificationItem childItem = (CertificationItem) itemsIterator.next();
                    rejectUnfinished(childItem);
                }
            }
        }
    }

        Certificationer certificationer = new Certificationer(context);
        certification = refreshCert(context, certificationer, certification);

        List errors = certificationer.sign(certification, null);
        showErrorsIfExists(errors);

    ]]>
  </Source>
</Rule>

<!--
  -  A RequestObjectSelector rule that generates a Fiter to return roles in the requestor's Department.
  -  This rule assumes that the object in question has an extended 'Department' attribute that correlates to an
  -  Identity attribute that is also named 'Department'.  In order to correlate with a different attribute,
  -  replace each instance of 'Department' with the desired attribute name.
  -->
<Rule language="beanshell" name="Roles in the Requestor's Department" type="RequestObjectSelector">
  <Description>This rule returns a Filter that restricts roles to those in the requestor's department</Description>
  <Signature returnType="sailpoint.object.Filter">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="requestor" type="sailpoint.object.Identity">
        <Description>
          Identity that is making the Life Cycle Manager request.
        </Description>
      </Argument>
      <Argument name="requestee" type="sailpoint.object.Identity">
        <Description>
          Identity on whose behalf the Life Cycle Manager request is being made.  In the case of bulk requests,
          this argument will be set to null when determining the roles that are visible to the requestor.
          It will be provided once a selection has been made in order to determine whether or not the given requestee
          should have access to the selected role.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="filter">
        <Description>
          A Filter object that will be used to search for accessible Roles.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.Filter;
      import sailpoint.object.Identity;
      return Filter.eq("Department", requestor.getAttribute("Department"));
    ]]>
  </Source>
</Rule>


<!--
  -   An AllowedValues rule that retrieves a list of approved auditor names
  -   from the system configuration.
  -->
<Rule language='beanshell' type='AllowedValues' name='Example Allowed Values Rule'>
  <Description>
    Allowed Values Rules are used by provisioning policies to determine the
    possible values of the policy fields.  Note that an Attributes map of all
    arguments from the current WorkflowContext is passed into the Allowed
    Values Rule, so any workflow context arguments are available within this rule.
  </Description>
  <Signature returnType='Object'>
    <Inputs>
      <Argument name='identity'>
        <Description>
          The Identity object being provisioned.
        </Description>
      </Argument>
      <Argument name='form'>
        <Description>
          The Form object for the provisioning plan.
        </Description>
      </Argument>
      <Argument name='field'>
        <Description>
          The Field object being analyzed.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='value'>
        <Description>
          An Obect (possibly a Collection) of the allowed values for the given
          field.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.configuration;
      import java.util.List;
      import java.util.ArrayList;

      List values = new ArrayList();

      if (form.getName().equalsIgnoreCase("audits")) {
          Configuration config = context.getConfiguration();
          values = config.getList("auditors");

           if (values == null)
              values = new ArrayList();
          }

      return values;
    ]]>
  </Source>
</Rule>


<!--
  -   A Validation rule that checks the value assigned to the Field named
  -   "backupMgr" to make sure the value is that of an actual manager.
  -->
<Rule language='beanshell' type='Validation' name='Example Validation Rule'>
  <Description>
    This rule is used to validate the Field values on a provisioning plan.
  </Description>
  <Signature returnType='Object'>
    <Inputs>
      <Argument name='identity'>
        <Description>
            The Identity object being provisioned.
        </Description>
      </Argument>
      <Argument name='app'>
        <Description>
            The Application object being processed.
        </Description>
      </Argument>
      <Argument name='form'>
        <Description>
            The Form object being processed.
        </Description>
      </Argument>
      <Argument name='field'>
        <Description>
            The Field object being validated.
        </Description>
      </Argument>
      <Argument name='value'>
        <Description>
            The Object representing the field value.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='value'>
        <Description>
          An Obect (possibly a Collection) of messages resulting from the
          validation rule.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.Identity;
      import java.util.List;
      import java.util.ArrayList;
      import java.lang.String;

      List msgs = new ArrayList();

      if (field.getName().equalsIgnoreCase("backupMgr")) {
          Identity backupMgr= null;
          if (value instanceof Identity)
              backupMgr= value;
          else
              backupMgr= context.getObjectByName(Identity.class, value.toString());

          if (backupMgr == null)
              msgs.add("No Identity found for backup manager: " + value);

          if ((backupMgr != null) && !backupMgr.getManagerStatus())
              msgs.add("Invalid backup manager - " + backupMgr.getDisplayableName()
                  + " is not a manager.");
      }

      return msgs;
    ]]>
  </Source>
</Rule>


<!--
  -   An Owner rule that determines the owner based on the data passed into the
  -   rule.
  -->
<Rule language='beanshell' type='Owner' name='Example Owner Rule'>
  <Description>
    Owner Rules are used by provisioning policies to determine the owner of the
    provisioning policy or its policy fields. 
  </Description>
  <Signature returnType='Object'>
    <Inputs>
      <Argument name='identity'>
        <Description>
          The Identity object being provisioned.
        </Description>
      </Argument>
      <Argument name='role'>
        <Description>
          The Role object involved in the provisioning processed.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          The Application object being provisioned.
        </Description>
      </Argument>
      <Argument name='template'>
        <Description>
          The Template object that defines the provisioning plan.
        </Description>
      </Argument>
      <Argument name='field'>
        <Description>
          The Field object being processed.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identity'>
        <Description>
          Either the Identity of the owner, or the type of template used to
          define the provisioning policy, from which the owner can be determined.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.Identity;

      Identity owner = null;
      if (role != null)
          owner = role.getOwner();
      else if (app != null)
          owner = app.getOwner();
      else
          owner = identity.getManager();

      if (owner == null)
          owner = context.getObjectByName(Identity.class, "spadmin");

      return owner;
    ]]>
  </Source>
</Rule>


<!-- 
  -  A Workflow rule that determines the approval owner.
  -->
<Rule language='beanshell' type='Workflow' name='Example Workflow Approval Owner Rule'>
  <Description>
    Workflow rules can be called in a variety of places within the workflow to
    do a number of different things.  This one uses a WorkflowContext variable
    called "identityName" to find the identity's manager and return the 
    manager's name as the approval owner. 
  </Description>
  <Signature returnType='Object'>
    <Inputs>
      <Argument name='wfcontext'>
        <Description>
          The current WorkflowContext.
        </Description>
      </Argument>
      <Argument name='handler'>
        <Description>
          The workflow handler associated with the current WorkflowContext.
        </Description>
      </Argument>
      <Argument name='workflow'>
        <Description>
          The current Workflow definition.
        </Description>
      </Argument>
      <Argument name='step'>
        <Description>
          The current Step.
        </Description>
      </Argument>
      <Argument name='approval'>
        <Description>
          The current Approval.
        </Description>
      </Argument>
      <Argument name='item'>
        <Description>
          The WorkItem being processed.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='Object'>
        <Description>
          The result of the workflow rule; dependent on the rule itself.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.object.Identity;

      String approvalOwner = null;
      Identity identity = context.getObjectByName(Identity.class, identityName);
      if (identity != null) {
          Identity mgr = identity.getManager();
          if (mgr != null)
              approvalOwner =  mgr.getDisplayableName();
      }
          
      return approvalOwner;
    ]]>
  </Source>
</Rule>

<Rule name='Example Domino Group Member Customization Rule'>
  <Description>
    This example can be used to derive a group attribute
    that reflects only group objects.  Its specifically
    designed with Domino in mind, but only uses the 
    attribute name from Domino and can easliy be changed.
      
    The underlying issue is that Domino's member list for
    groups includes both user's and group objects.  To use
    IIQs group hierarchy the value needs to include only 
    other group object dn's.
    
    This doesn't come for free, and requires us to query
    back to ldap to try and bind to an object using the
    connector.  If the bind throws ObjectNotFoundException
    we can assume the object type.
    
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application that references the connector
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
          The connector object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='A ResourceObject'>
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
      import sailpoint.tools.Util;
      import sailpoint.object.ResourceObject;
      import sailpoint.connector.Connector;
      import sailpoint.connector.ObjectNotFoundException;
      
      // Name of the attribute that contains both User and Groups
      // in Domino this is an attribute on each group attribute and
      // named "Member"
      String GROUPS_AND_USERS_ATTRIBUTE_NAME = "Member";
      
      // The name of the assimilated attribute that has been filtered to 
      // contain only groups in the value
      String GROUPS_ONLY_ATTRIBUTE_NAME = "GroupOnlyMember";
      
      /**
       * Iterate over the values in the attribute that represents
       * all members and build a list that represent only 
       * group objects.
       */
      private ResourceObject deriveGroupOnlyMemberAttribute(ResourceObject object) {
          List groupsOnly = new ArrayList();
          List members = Util.asList(object.getAttribute(GROUPS_AND_USERS_ATTRIBUTE_NAME));
          if ( members != null ) {	
             for ( String member : members ) {
                 ResourceObject connectorObj = null;
                 try {
                     Map options = new HashMap();
                     options.put("objectAttributeNames", Util.csvToList("cn"));
                     connectorObj = connector.getObject(Connector.TYPE_GROUP, member, options);
                 } catch(ObjectNotFoundException e ) {
                     // this would indicate its not a group
                 }
                 if ( connectorObj != null ) {
                     if ( !groupsOnly.contains(member) ) { 
                         groupsOnly.add(member);
                     }
                 }
              }
          }
          if ( Util.size(groupsOnly) > 0 ) {
               object.put(GROUPS_ONLY_ATTRIBUTE_NAME, groupsOnly);
          }
          return object;   
      }
 
      //
      // Rule Entry
      // 
      
      // abnormal condition but guard against it
      if ( object == null ) {
          return object;
      }
      
      //
      // Only interested in customizing group objects
      // so check the type on each object
      //
      if ( Util.nullSafeCompareTo(object.getObjectType(),Connector.TYPE_GROUP ) == 0 ) {
          object = deriveGroupOnlyMemberAttribute(object);
      }       
      return object;
    ]]>
  </Source>
</Rule>


<Rule name='Example Policy Rule' type='Policy'>
  <Description>
    This example looks for identities that haven't logged in for at least 180
    days, in violation of a policy that prohibits stale users.    
  </Description>
  <Signature returnType='PolicyViolation'>
    <Inputs>
      <Argument name='identity'>
        <Description>
          The Identity being inspected.
        </Description>
      </Argument>
      <Argument name='policy'>
        <Description>
          The Policy being evaluated.
        </Description>
      </Argument>
      <Argument name='constraint'>
        <Description>
          The Constraint being evaluated.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='violation'>
        <Description>
          The PolicyViolation object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
import sailpoint.api.SailPointContext;
import sailpoint.object.Attributes;

import sailpoint.object.Custom;
import sailpoint.object.Filter;
import sailpoint.object.Identity;
import sailpoint.object.QueryOptions;
import sailpoint.object.Policy;
import sailpoint.object.PolicyViolation;
import sailpoint.object.Link;

import sailpoint.tools.GeneralException;
import sailpoint.tools.Message;

import java.text.SimpleDateFormat;
import java.text.DateFormat;
import java.util.*;

        /**
         * Returns a date <n> days before today.
         */

        private Date getDateNDaysAgo(int numDays) {
                System.out.println("entering getDateNDaysAgo");

                Calendar cal = Calendar.getInstance();
                Date returnDate = null;

                cal.add(Calendar.DATE, -(numDays));
                returnDate = cal.getTime();
                System.out.println("leaving with date" + returnDate);
                return (returnDate);
        }

      /**
     * Checks if the first date is before the second date ignoring time.
     **/

    public static boolean isBeforeDay(Date date1, Date date2) {
        if (date1 == null || date2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        Calendar cal1 = Calendar.getInstance();
        cal1.setTime(date1);
        Calendar cal2 = Calendar.getInstance();
        cal2.setTime(date2);
        return isBeforeDay(cal1, cal2);
    }
           
    /**
     * Checks if the first calendar date is before the second calendar date ignoring time.
     */
    public static boolean isBeforeDay(Calendar cal1, Calendar cal2) {
        if (cal1 == null || cal2 == null) {
            throw new IllegalArgumentException("The dates must not be null");
        }
        if (cal1.get(Calendar.ERA) < cal2.get(Calendar.ERA)) return true;
        if (cal1.get(Calendar.ERA) > cal2.get(Calendar.ERA)) return false;
        if (cal1.get(Calendar.YEAR) < cal2.get(Calendar.YEAR)) return true;
        if (cal1.get(Calendar.YEAR) > cal2.get(Calendar.YEAR)) return false;
        return cal1.get(Calendar.DAY_OF_YEAR) < cal2.get(Calendar.DAY_OF_YEAR);
    }
        
    PolicyViolation v = null;
    Date lastLoginDate = identity.getLastLogin();
    if (lastLoginDate == null)
        lastLoginDate = new Date();

    System.out.println("Last Login Date for" + identity.toString() + " = " + lastLoginDate);

    Date testDate = getDateNDaysAgo(180);
        if (isBeforeDay(lastLoginDate, testDate)) {
           System.out.println("old date");
           v = new PolicyViolation();
           v.setActive(true);
           v.setIdentity(identity);
           v.setPolicy(policy);
           v.setConstraint(constraint);
           v.setDescription("[Last Login Date [" + lastLoginDate.toString()  + "] is more than 180 days ago.]");
           v.setStatus(sailpoint.object.PolicyViolation.Status.Open);
    }

    return v;
    ]]>
  </Source>
</Rule>

<Rule name="Example Self-certifier Forward to Manager Rule" type="FallbackWorkItemForward">
  <Description>This example falls back to the owner's manager as the new owner of the work item.  If the owner 
  has no manager, then fall back to the creator of the certification.</Description>
  <Signature returnType="Object">
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="item" type="WorkItem">
        <Description>The WorkItem needing to be forwarded. The WorkItem properties may not be fully populated yet.</Description>
      </Argument>
      <Argument name="owner" type="Identity">
        <Description>The Identity that currently owns the work item.</Description>
      </Argument>
      <Argument name="creator" type="String">
        <Description>The name of identity that created the certification belonging to the work item.</Description>
      </Argument>
      <Argument name="certifiers" type="List&lt;String>">
        <Description>A list of certifier names for the certification belonging to the work item.</Description>
      </Argument>
      <Argument name="name" type="String">
          <Description>The name of the certification belonging to the work item. It may be null if certification is not created yet.</Description>
      </Argument>
      <Argument name="type" type="Certification.Type">
          <Description>The type of the certification belonging to the work item.</Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name="newOwner">
        <Description>An Identity that should own the work item.  Alternatively, this can
be a String that is the name or id of the Identity.</Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>

import sailpoint.object.Certification;
  
System.out.println("Executing Fallback work item forward rule.");
System.out.println("Owner: " + owner.getName());
System.out.println("Certification name: " + name);
System.out.println("Certification creator: " + creator);
System.out.println("Certification certifiers: " + certifiers);


if (Certification.Type.Manager.equals(type) ||
     Certification.Type.Identity.equals(type)) {
	if (owner.getManager() != null) {
	   newOwner = owner.getManager().getName();
	} else { 
	   newOwner = creator;
	}
} else {
   newOwner = owner.getName();
   System.out.println("Keep existing owner for cert type" + type);
}

System.out.println("Completed Fallback work item forward rule.");
System.out.println("Forwarding to " + newOwner);

return newOwner;</Source>
</Rule>
<Rule language='beanshell' name='Example Policy Owner Rule' type='PolicyOwner'>
  <Description>
    This example simply returns spadmin as an owner for all policies.
  </Description>
  <Signature returnType='Identity'>
    <Inputs>
      <Argument name='environment' type='java.util.Map' required='true'>
        <Description>
          The task arguments passed to the aggregation or refresh task.
        </Description>
      </Argument>
      <Argument name='policy'>
        <Description>
          The Policy being evaluated.
        </Description>
      </Argument>
      <Argument name='constraint'>
        <Description>
          The Constraint associated with the violation. Provided if available, it is possible for this to be null.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='identity'>   
        <Description>
        The return value for the policy owner may be:
        
           String - identity name;
           Identity - identity object;
           List&lt;String&gt; - list of identity names;
           List&lt;identity&gt; - list of identity objects;
           Map containing key "identity" whose value is an Identity object;
           Map containing key "identityName" whose value is a String         
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
        import sailpoint.object.Identity;

        return context.getObjectByName(Identity.class, "spadmin");
    ]]>
  </Source>
</Rule>
<Rule language="beanshell" name="BeforeCreate-Powershell" type="ConnectorBeforeCreate">
  <Attributes>
    <Map>
      <entry key="ObjectOrientedScript" value="true"/>
      <entry key="disabled" value="false"/>
      <entry key="extension" value=".ps1"/>
      <entry key="program" value="powershell.exe"/>
      <entry key="timeout" value="10"/>
    </Map>
  </Attributes>
   <Description>
  This example is for IQService Before Script.  This is a sample PowerShell before script which modifies value of an attribute and add one new attribute
to the request
  </Description>
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="plan">
        <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object that references this before/after script.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
  # Refer to SailPoint class library Requires PowerShell v2 installed on the system.
        Add-type -path utils.dll
        # Read the environment variables
        $sReader = New-Object System.IO.StringReader([System.String]$env:Request);
        # Form the xml reader object
        $xmlReader =
        [System.xml.XmlTextReader]([sailpoint.Utils.xml.XmlUtil]::getReader($sReader));
        # Create SailPoint Request object
        $requestObject = New-Object
        Sailpoint.Utils.objects.AccountRequest($xmlReader);
        # Loop through the attributes from the request
        foreach ($attribute in $requestObject.AttributeRequests){
            if($attribute.Name -eq "description"){
                $attribute.value = "my description";#change value of the attribute
            }
        }
        # Add a new attribute to request
        $attributeObject = New-Object Sailpoint.Utils.objects.AttributeRequest;
        $attributeObject.Name = "otherMobile";
        $otherMobileValues = New-Object System.Collections.ArrayList;
        $otherMobileValues.Add("222-292-2929");
        $otherMobileValues.Add("333-292-2929");
        $attributeObject.Value= $otherMobileValues;
        $attributeObject.Operation = "Set";
        $requestObject.AttributeRequests.Add($attributeObject);
        # Write the request xml to file at the path passed as argument
        $requestObject.toxml()|out-file $args[0];
</Source>
</Rule>
<Rule language="beanshell" name="AfterCreate-Powershell" type="ConnectorAfterCreate">
  <Attributes>
    <Map>
      <entry key="ObjectOrientedScript" value="true"/>
      <entry key="disabled" value="false"/>
      <entry key="extension" value=".ps1"/>
      <entry key="program" value="powershell.exe"/>
      <entry key="timeout" value="10"/>
    </Map>
  </Attributes>
   <Description>
  This example is for IQService Before Script.  This is a sample PowerShell after script which ensures that the request was processed successfully and
creates home directory at the path specified in the request
  </Description>
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="plan">
        <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object that references this before/after script.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
  # Refer to SailPoint class library Requires PowerShell v2 installed on the system.
       # Refer to SailPoint class library. Requires PowerShell v2 installed on the system.
        Add-type -path utils.dll
        # Read the environment variables
        $sReader = New-Object System.IO.StringReader([System.String]$env:Request);
        $sResult = New-Object System.IO.StringReader([System.String]$env:Result);
        # Form the xml reader objects
        $xmlReader = [
        System.xml.XmlTextReader]([sailpoint.utils.xml.XmlUtil]::getReader($sReader));
        $xmlReader_Result = [System.xml.XmlTextReader]([sailpoint.utils.xml.XmlUtil]::getReader($sResult));
        # Create SailPoint objects
        $requestObject = New-Object
        Sailpoint.Utils.objects.AccountRequest($xmlReader);
        $resultObject = New-Object
        Sailpoint.Utils.objects.ServiceResult($xmlReader_Result);
        #Check if the request was processed successfully
        if($resultObject.Errors.count -eq 0){
                #Get Home directory path
                foreach ($attribute in $requestObject.AttributeRequests){
                        #Create Home directory
                        if($attribute.Name -eq "TS_TerminalServicesHomeDirectory"){
                        new-item $attribute.Value -itemtype directory;
                        }
                }
        }
</Source>
</Rule>
<Rule language="beanshell" name="AfterCreate-Batch" type="ConnectorAfterCreate">
  <Attributes>
    <Map>
      <entry key="disabled" value="false"/>
      <entry key="timeout" value="10"/>
    </Map>
  </Attributes>
   <Description>
   This example is for IQService Before Script.  This is a sample batch after script which ensures that the request was processed successfully and creates
home directory at the path specified in the request
  </Description>
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="plan">
        <Description>
          The ProvisioningPlan object on its way to the Connector.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object that references this before/after script.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
	IF %Result% == SUCCESS md %SP_Set_TS_TerminalServicesHomeDirectory%
</Source>
</Rule>

<!--  
   Rule called when the default LCM Provisioning and LCM Manage Passwords are
   creating and updating tickets as workflows go through thier lifecycles.
 -->
<Rule language="beanshell" name='Example Ticket Plan Generation Rule'>

  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="wfc">
        <Description>
          The currently execution workflow context.
        </Description>
      </Argument>     
      <Argument name="project">
        <Description>
          The project that we are dealing with in the provisioning workflow.
          This argument comes from the workflow context and is here for convenience.
        </Description>
      </Argument>        
      <Argument name="identityRequest">
        <Description>
          The object.IdentityRequest object that contains all of the current request information,
          including approval and provisioning information depending on where in the process
          we are being launched.
          
          This argument comes from the workflow context and is here for convenience.
        </Description>
      </Argument>   
      <Argument name="appName">
        <Description>
          The name of the application that should handle the ticket management.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object representing the application that should handle the ticket management.
        </Description>
      </Argument>      
    </Inputs>
  </Signature>
                            
  <Description>
    Given the current workflow context, using mostly the identityRequest
    object build a plan that should represent the ticket data that
    needs to be pushed into the Remedy Ticket.
  </Description>
  
  <Source>
    <![CDATA[
     import sailpoint.api.IdentityRequestProvisioningScanner;
     import sailpoint.object.Attributes;
     import sailpoint.object.Filter;
     import sailpoint.object.Identity;
     import sailpoint.object.IdentityRequest;
     import sailpoint.object.IdentityRequestItem;
     import sailpoint.object.ProvisioningPlan;
     import sailpoint.object.ProvisioningPlan.AccountRequest;
     import sailpoint.object.ProvisioningPlan.AttributeRequest;     
     import sailpoint.object.ProvisioningPlan.Operation;
     import sailpoint.object.ProvisioningPlan.ObjectRequest;
     import sailpoint.object.ProvisioningPlan.ObjectOperation;
     import sailpoint.object.QueryOptions;
     import sailpoint.object.WorkItem;
     import sailpoint.task.IdentityRequestMaintenance;
     import sailpoint.workflow.WorkflowContext;
     import sailpoint.tools.Util;
     import sailpoint.web.util.IdentityRequestSummarizer;
     
     /**
      * Add an ObjectRequest that will represent the ticket to the constructed plan,
      * and return it.  Consumer can populate the attribute request's as 
      * required.
      */               
     private ObjectRequest initPlan(ProvisioningPlan plan, String action, IdentityRequest ir, String application) {
         ObjectRequest req = new ObjectRequest();     
         if ( action.startsWith("open") )  { 
            req.setOp(ObjectOperation.Create);    
         } else {
            req.setOp(ObjectOperation.Modify);
            if ( ir != null ) 
                req.setNativeIdentity(ir.getExternalTicketId());
         }
         req.setType("ticket");
         req.setApplication(application);
         // add the request to the plan
         plan.addObjectRequest(req);                 
         return req;
     }    
     
     /**
      * Add in specific "requested for" Identity information to the ticket
      * using a project query to limit the database data we bring
      * back.
      */
     private void addIdentityInfo(ObjectRequest req, String identityId) {
         QueryOptions ops = new QueryOptions();         
         ops.addFilter(Filter.eq("id", identityId));
         Iterator rows = context.search(Identity.class, ops, "firstname, lastname, email");
         while ( rows != null && rows.hasNext() ) {
             Object[] row = (Object[]) rows.next();
             if ( row != null ) {
                 if ( row.length == 3 ) { 
                    String first = row[0];
                    if ( first != null ) {
                        req.add( new AttributeRequest("firstName", first) );
                    } else {
                        req.add( new AttributeRequest("firstName", "unknownFirstName") );
                    }
                    String last = row[1];
                    if ( last != null ) {
                        req.add( new AttributeRequest("lastName", last) );
                    } else {
                        req.add( new AttributeRequest("lastName", "unknownLastName") );
                    }
                    if ( first != null && last != null )  
                       req.add( new AttributeRequest("fullname", first + " " + last) );
                       
                    String email = row[2];
                    if ( email != null )
                        req.add( new AttributeRequest("email", email) );       
                 }
             } 
         }        
     } 
          
     /**
      * Build out a plan that can be used by a ticketing system
      * to open a ticket with enough information to understand 
      * what was requested.
      */
     private ProvisioningPlan buildOpenTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();
         
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);
         
         if ( "openNoApproval".equals(action) ) {
             req.add( new AttributeRequest("Status", "In Progress") );
             req.add( new AttributeRequest("Status_Reason", "By Provider") );   
             req.add( new AttributeRequest("Summary", "IdentityIQ Provisioning Request Started") );                         
         } else{         
             req.add( new AttributeRequest("Status", "Waiting Approval") );
             req.add( new AttributeRequest("Status_Reason", "Approval") );
             req.add( new AttributeRequest("Summary", "IdentityIQ Provisioning Request Started - Awaiting Approval") );         
         }
                   
         //
         // Using the identity request build up the base request
         // informtion.
         //
                  
         req.add( new AttributeRequest("urgency", "3-Medium") );
         req.add( new AttributeRequest("impact", "3-Moderate/Limited") );
           
         
         String launcherName = wfc.get("launcher");
         if ( launcherName != null ) {             
             req.add( new AttributeRequest("loginId", launcherName) );
         }                  
         String description = ir.getTargetDisplayName() + " IdentityIQ " + ir.getType();         
         req.add( new AttributeRequest("description", description) );                  
         req.add( new AttributeRequest("appRequestSummary", ir.getType()) );
         
         //
         // Query for the identity properties that are useful for the 
         // ticket data and add to the objectRequest
         //
         addIdentityInfo(req, ir.getTargetId());
         
         String link = "http://yourServer:8080/identityiq/manage/accessRequest/accessRequestCompleteDetails.jsf?id="+ir.getId();         
         String details = IdentityRequestSummarizer.summarizeItemsHTML(ir, getOptions()) +  "&lt;br> For additional information click the link below: &lt;br>" + link;
         
         req.add( new AttributeRequest("Notes", details) );                  
         req.add( new AttributeRequest("Submitter", ir.getRequesterDisplayName()) );
 
         return ticketPlan;
     }
     
     /**
      * Post approval build a summary of the items with the decisions and 
      * add them to an existing ticket.
      */
     private ProvisioningPlan buildPostApprovalTicketPlan(String action, IdentityRequest ir, String application) {    
         ProvisioningPlan ticketPlan = new ProvisioningPlan();         
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);
         
         req.add( new AttributeRequest("Notes", ProvisioningPlan.Operation.Add, IdentityRequestSummarizer.summarizeItemApprovalsHTML(ir, getOptions())) );         
         req.add( new AttributeRequest("Summary", "IdentityIQ Post Approval Update") );
         req.add( new AttributeRequest("Submitter", ir.getRequesterDisplayName()) );
         
         req.add( new AttributeRequest("Status_Reason", "By Provider") ); 
         req.add( new AttributeRequest("Status", "In Progress") );         
         req.add( new AttributeRequest("Details", "IdentityIQ Performing Provisioning") );
         
         return ticketPlan;         
     }     
     
     /**
      * Post provisioning build a summary of the items and the provisioning
      * status for each of the items and add them to an existng
      * ticket.
      */
     private ProvisioningPlan buildPostProvisioningTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();         
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);

         req.add( new AttributeRequest("Notes", ProvisioningPlan.Operation.Add, IdentityRequestSummarizer.summarizeItemProvisioningHTML(ir,getOptions())) );
         req.add( new AttributeRequest("Summary", "IdentityIQ Post Provisioning Update") );         
         req.add( new AttributeRequest("Submitter", ir.getRequesterDisplayName()) );       
         
         req.add( new AttributeRequest("Status_Reason", "By Provider") );
         req.add( new AttributeRequest("Status", "Completed") );
         req.add( new AttributeRequest("Details", "IdentityIQ Provisioning Request Finishing") );
                  
         return ticketPlan;         
     }

      private void scanIdentityRequest(IdentityRequest request) {
           Attributes args = new Attributes();
           args.put(IdentityRequestMaintenance.ARG_SCAN_IDENTITY_REQUESTS, true);
           IdentityRequestProvisioningScanner scanner = new IdentityRequestProvisioningScanner(context, args);
           scanner.scan(request);
      }

     
     /**
      * After the workflow has completed with or without error) summarize the
      * overall request status.
      */
     private ProvisioningPlan buildCompleteProvisioningTicketPlan(String action, IdentityRequest ir, String application) {
         scanIdentityRequest(ir);
         ProvisioningPlan ticketPlan = new ProvisioningPlan();         
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);
         
         req.add( new AttributeRequest("Notes", ProvisioningPlan.Operation.Add, IdentityRequestSummarizer.summarizeCompleteHTML(ir, getOptions()) ) );
         req.add( new AttributeRequest("Summary", "IdentityIQ Request Completed") );
         req.add( new AttributeRequest("Submitter", ir.getRequesterDisplayName()) );  
         if ( ir.isTerminated() ) {         
             req.add( new AttributeRequest("Status", "Cancelled") );         
             req.add( new AttributeRequest("Status_Reason", "By User") );        
             req.add( new AttributeRequest("Details", "IdentityIQ Provisioning Request Canceled") );                          
         } else         
         if ( ir.isSuccessful() ) {
            req.add( new AttributeRequest("Status", "Closed") );
            req.add( new AttributeRequest("Status_Reason", "Successful") );
            req.add( new AttributeRequest("Details", "IdentityIQ Provisioning Request Completed") );
         } else
         if ( ir.isIncomplete() ) { 
             req.add( new AttributeRequest("Status", "Closed") );
             req.add( new AttributeRequest("Status_Reason", "With Issues") );
             req.add( new AttributeRequest("Details", "IdentityIQ Provisioning Request - One or more items failed") );
         }  else
         if ( ir.isFailure() ) {
            req.add( new AttributeRequest("Status", "Closed") );         
            req.add( new AttributeRequest("Status_Reason", "System Errors") );
            req.add( new AttributeRequest("Details", "IdentityIQ Provisioning Request Failed") );            
         }         
         return ticketPlan;         
     }       
     
     Map _appMapping;
     
     /**
      * Build this map once....
      */
     private Map getApplicationMapping() {
        if ( _appMapping == null ) {
            _appMapping = new HashMap();
            _appMapping.put("IIQ", "Identity IQ");
            _appMapping.put("LCM Test App1", "Global schematic flux capacitor data store");
        } 
        return _appMapping;
     }
     
     /**
      * Method to return options for the calls into the identity request to html rendering code.
      */
     private Map getOptions() {     
         Map options = new HashMap();
         options.put(IdentityRequestSummarizer.OP_APPLICATION_MAPPING, getApplicationMapping());
         return options;     
     }
       
     ///////////////////////////////////////////////
     // Main
     //////////////////////////////////////////////

//System.out.println("ENTER1. Ticket plan generation rule start." + action);       
     ProvisioningPlan ticketPlan = null;
     
     if ( identityRequest == null ) {
         throw new Exception("Identity request was null, unable to build ticket plan.");
     }           
     if ( Util.nullSafeEq(action, "open" ) || Util.nullSafeEq(action, "openNoApproval" ) ) {
         ticketPlan = buildOpenTicketPlan(action, identityRequest, appName);
     } else    
     if ( Util.nullSafeEq(action, "postApproval" ) ) {
         ticketPlan = buildPostApprovalTicketPlan(action, identityRequest, appName);              
     } else 
     if ( Util.nullSafeEq(action, "postProvisioning" ) ) {
         ticketPlan = buildPostProvisioningTicketPlan(action, identityRequest, appName);              
     } else
     if ( Util.nullSafeEq(action, "complete" ) ) {
         ticketPlan = buildCompleteProvisioningTicketPlan(action, identityRequest, appName);              
     } else {
         throw new Exception("Unhandled action "+action+"' passed into ticket generation rule. Plan could not be generated");
     }
//System.out.println("EXIT1. Ticket plan generation rule end.\n" + ticketPlan.toXml());
     return ticketPlan;
    ]]>
  </Source>
</Rule>

<!--
   Rule called when the default LCM Provisioning and LCM Manage Passwords are
   creating and updating tickets(for ServiceNow) as workflows go through thier lifecycles.
 -->
<Rule language="beanshell" name='ServiceNow Example Ticket Plan Generation Rule'>
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="wfc">
        <Description>
          The currently execution workflow context.
        </Description>
      </Argument>
      <Argument name="project">
        <Description>
          The project that we are dealing with in the provisioning workflow.
          This argument comes from the workflow context and is here for convenience.
        </Description>
      </Argument>
      <Argument name="identityRequest">
        <Description>
          The object.IdentityRequest object that contains all of the current request information,
          including approval and provisioning information depending on where in the process
          we are being launched.

          This argument comes from the workflow context and is here for convenience.
        </Description>
      </Argument>
      <Argument name="appName">
        <Description>
          The name of the application that should handle the ticket management.
        </Description>
      </Argument>
      <Argument name="application">
        <Description>
          The application object representing the application that should handle the ticket management.
        </Description>
      </Argument>
    </Inputs>
  </Signature>

  <Description>
    Given the current workflow context, using mostly the identityRequest
    object build a plan that should represent the ticket data that
    needs to be pushed into the Remedy Ticket.
  </Description>

  <Source>
    <![CDATA[
     import java.util.ArrayList;
     import java.util.List;
     import java.util.Date;
     import java.util.Map;
     import sailpoint.object.Application;
     import sailpoint.object.Filter;
     import sailpoint.object.Identity;
     import sailpoint.object.IdentityRequest;
     import sailpoint.object.IdentityRequestItem;
     import sailpoint.object.ProvisioningPlan;
     import sailpoint.object.ProvisioningPlan.AccountRequest;
     import sailpoint.object.ProvisioningPlan.AttributeRequest;
     import sailpoint.object.ProvisioningPlan.Operation;
     import sailpoint.object.ProvisioningPlan.ObjectRequest;
     import sailpoint.object.ProvisioningPlan.ObjectOperation;
     import sailpoint.object.QueryOptions;
     import sailpoint.object.Schema;
     import sailpoint.object.WorkItem;
     import sailpoint.workflow.WorkflowContext;
     import sailpoint.tools.Util;
     import sailpoint.web.util.IdentityRequestSummarizer;

     /**
      * Fields
      */
     Date date = new Date();
     String stdformat = Util.dateToString(date);

     /**
      * populate transaction data (required for service now rest API)
      */
     private void getTransactionData( ObjectRequest req, IdentityRequest ir, String requestType ) {
         req.add( new AttributeRequest( "transaction_type", requestType ) );
         req.add( new AttributeRequest( "transaction_id", Util.uuid() ) );
         req.add( new AttributeRequest( "transaction_date", ir.getCreated().toString() ) );
     }

     /**
      *
      * Returns the type Identity Request Item when the item is either and IIQ assigned and detectedRoles
      * or attributes that are marked entitlement in the schema.
      *
      */
     private String getIdentityRequestItemType(IdentityRequestItem item) {
        String itemAttributeName = item.getName();
        if ( null == itemAttributeName ) {
             return null;
        }
        if ( Util.nullSafeEq(itemAttributeName, "assignedRoles" ) || Util.nullSafeEq(itemAttributeName, "detectedRoles" ) ) {
             return "Role";
        }

        String app = item.getApplication();
        if ( null == app ) {
            return "unknown";
        }
        Application appObject = context.getObjectByName(Application.class, app);
        if ( null != appObject ) {
             Schema account = appObject.getAccountSchema();
             if ( null != account ) {
                  List entitlementAttributes = account.getEntitlementAttributeNames();
                  if ( entitlementAttributes != null  ) {
                       if ( entitlementAttributes.contains(itemAttributeName) )
                            return "Entitlement";
                  }
             }
        }
        else {
              return "unknown";
        }
        return "unknown";
     }

     /**
      * Add in specific "requested_for" Identity information to the ticket
      * using a project query to limit the database data we bring
      * back.
      */
     private String addIdentityInfo(String identityId) {
         String rc = null;
         QueryOptions ops = new QueryOptions();
         ops.addFilter(Filter.eq("id", identityId));
         Iterator rows = context.search(Identity.class, ops, "name");
         while ( rows != null && rows.hasNext() ) {
             Object[] row = (Object[]) rows.next();
             if ( row != null && row.length == 1) {
                    String name = row[0];
                    if ( null != name )
                       rc = name;
             }
         }
         if ( null != rc)
             return rc;

         return "unknown";
     }

     /**
      *  Method to return particular Item information from Identity Request object
      */
     private ArrayList getItemsList(IdentityRequest ir) {
        ArrayList itemsList = new ArrayList ();
        List exItems = ir.getItems();
        if ( null != exItems && ( 0 != exItems.size() ) ) {
             for ( IdentityRequestItem item : exItems ) {
                   if ( null != item ) {
                        Map exMap = new HashMap();
                        exMap.put( "item_id", item.getId());
                        exMap.put( "type", getIdentityRequestItemType( item ) );
                        exMap.put( "value", item.getValue() );
                        exMap.put( "application", item.getApplication() );
                        exMap.put( "account_name", item.getNativeIdentity() );
                        exMap.put( "operation", item.getOperation() );
                        exMap.put( "approval_state", item.getApprovalState() );
                        if ( item.ProvisioningState.Commited.equals(item.getProvisioningState()) ) {
                            exMap.put( "provisioning_state", "Committed" );
                        }
                        else {
                            exMap.put( "provisioning_state", item.getProvisioningState() );
                        }
                        if ( null != exMap && ( 0 != exMap.size() ) ) {
                              itemsList.add( exMap );
                        }
                    }
                }
           }
        if ( null != itemsList && ( 0 != itemsList.size() ) ) {
               return (itemsList);
        }

        return (null);
     }

     /**
      *  Method to return data information map
      */
     private Map getDataInfo(IdentityRequest ir) {
        Map dataMap = new HashMap();

        dataMap.put( "unique_key", ir.getName() );
        dataMap.put( "requested_for", addIdentityInfo( ir.getTargetId() ) );
        dataMap.put( "requestor", ( null != wfc.get("launcher") ) ? wfc.get("launcher") : "unknown" );

        /**
         * Using the identity request build up the Account request
         * informtion.
         */
        List itemsList = getItemsList(ir);
        if ( null != itemsList ) {
             dataMap.put( "items", itemsList );
        }

        dataMap.put( "status", ("openNoApproval".equals(action)) ? "In Progress" : "Waiting Approval" );
        dataMap.put( "created",  stdformat );
        dataMap.put( "updated", stdformat );
        dataMap.put( "comments", ( "openNoApproval".equals(action) ) ? "IdentityIQ Provisioning Request Started - No Approval"
                : "IdentityIQ Provisioning Request Started - Awaiting Approval" );

        return dataMap;
     }

     /**
      * Add an ObjectRequest that will represent the ticket to the constructed plan,
      * and return it.  Consumer can populate the attribute request's as
      * required.
      */
     private ObjectRequest initPlan(ProvisioningPlan plan, String action, IdentityRequest ir, String application) {
         ObjectRequest req = new ObjectRequest();
         if ( action.startsWith("open") ) {
            req.setOp( ObjectOperation.Create );
         }
         else {
            req.setOp( ObjectOperation.Modify );
            if ( ir != null )
               req.setNativeIdentity(ir.getExternalTicketId());
         }
         req.setType("ticket");
         req.setApplication(application);

         /**
          * add the request to the plan
          */
         plan.addObjectRequest(req);
         return req;
     }

     /**
      * Build out a plan that can be used by a ticketing system
      * to open a ticket with enough information to understand
      * what was requested.
      */
     private ProvisioningPlan buildOpenTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();

         ObjectRequest req = initPlan(ticketPlan, action, ir, application);

         /**
          * Using the identity request build up the base request informtion.
          */
         getTransactionData( req, ir, "request_create" );

         /**
          * Using the identity request build up the data request informtion.
          */
         req.add( new AttributeRequest( "data", getDataInfo(ir) ) );

         return ticketPlan;
     }

     /**
      * Post approval build a summary of the items with the decisions and
      * add them to an existing ticket.
      */
     private ProvisioningPlan buildPostApprovalTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);

         /**
          * Using the identity request build up the base request informtion.
          */
         getTransactionData( req, ir, "request_update" );

         /**
          * Using the identity request build up the data request informtion.
          */
         Map dataMap = new HashMap();
         dataMap.put( "unique_key", ir.getName() );
         dataMap.put( "status", "In Progress" );

         /**
          * Using the identity request build up the Account request
          * informtion.
          */
          List itemsList = getItemsList(ir);
          if ( null != itemsList ) {
               dataMap.put( "items", itemsList );
          }

         dataMap.put( "created", stdformat );
         dataMap.put( "updated", stdformat );
         dataMap.put( "comments", "IdentityIQ Performing Provisioning" );

         req.add( new AttributeRequest( "data", dataMap ) );

         return ticketPlan;
     }

     /**
      * Post provisioning build a summary of the items and the provisioning
      * status for each of the items and add them to an existng
      * ticket.
      */
     private ProvisioningPlan buildPostProvisioningTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);

         /**
          * Using the identity request build up the base request informtion.
          */
         getTransactionData( req, ir, "request_update" );

         /**
          * Using the identity request build up the data request informtion.
          */
         Map dataMap = new HashMap();
         dataMap.put( "unique_key", ir.getName() );
         dataMap.put( "status", "Completed" );

         /**
          * Using the identity request build up the Account request
          * informtion.
          */
          List itemsList = getItemsList(ir);
          if ( null != itemsList ) {
               dataMap.put( "items", itemsList );
          }

         dataMap.put( "created", stdformat );
         dataMap.put( "updated", stdformat );
         dataMap.put( "comments", "IdentityIQ Provisioning Request Finishing" );

         req.add( new AttributeRequest( "data", dataMap ) );

         return ticketPlan;
     }

     /**
      * After the workflow has completed with or without error) summarize the
      * overall request status.
      */
     private ProvisioningPlan buildCompleteProvisioningTicketPlan(String action, IdentityRequest ir, String application) {
         ProvisioningPlan ticketPlan = new ProvisioningPlan();
         ObjectRequest req = initPlan(ticketPlan, action, ir, application);

         /**
          * Using the identity request build up the base request informtion.
          */
         getTransactionData( req, ir, "request_update" );

         /**
          * Using the identity request build up the data request informtion.
          */
         Map dataMap = new HashMap();

         dataMap.put( "unique_key", ir.getName() );
         dataMap.put( "created", stdformat );
         dataMap.put( "updated", stdformat );

         /**
          * Using the identity request build up the Account request
          * informtion.
          */
          List itemsList = getItemsList(ir);
          if ( null != itemsList ) {
               dataMap.put( "items", itemsList );
          }

         if ( ir.isTerminated() ) {
              dataMap.put( "status", "Cancelled" );
              dataMap.put( "comments", "IdentityIQ Provisioning Request Canceled" );
         } else
         if ( ir.isSuccessful() ) {
              dataMap.put( "status", "Closed" );
              dataMap.put( "comments", "IdentityIQ Provisioning Request Completed" );
         } else
         if ( ir.isIncomplete() ) {
              dataMap.put( "status", "Closed" );
              dataMap.put( "comments", "IdentityIQ Provisioning Request - One or more items failed" );
         }  else
         if ( ir.isFailure() ) {
              dataMap.put( "status", "Closed" );
              dataMap.put( "comments", "IdentityIQ Provisioning Request Failed" );
         }

         req.add( new AttributeRequest( "data", dataMap ) );

         return ticketPlan;
     }

     ////////////////////////////////////////////////////////////////////////////////////////////////////
     // Main
     ////////////////////////////////////////////////////////////////////////////////////////////////////

     /*
     System.out.println("ENTER1. Ticket plan generation rule start.ticketId="  ticketId);
     System.out.println("ENTER1. Ticket plan generation rule start.priority="  priority);
     System.out.println("ENTER1. Ticket plan generation rule start.application="  application);
     System.out.println("ENTER1. Ticket plan generation rule start.action="  action);
     System.out.println("ENTER1. Ticket plan generation rule start.identityRequest="  identityRequest);
     System.out.println("ENTER1. Ticket plan generation rule start.identityRequestId="  identityRequestId);
     System.out.println("ENTER1. Ticket plan generation rule start.project="  project);
     System.out.println("ENTER1. Ticket plan generation rule start.appName="  appName);
     System.out.println("ENTER1. Ticket plan generation rule start.ticketManagementApplication="  ticketManagementApplication);
     System.out.println("ENTER1. Ticket plan generation rule start.context="  context);
     System.out.println("ENTER1. Ticket plan generation rule start.wfc="  wfc);
     System.out.println("ENTER1. Ticket plan generation rule start.wfcase="  wfcase);
     System.out.println("ENTER1. Ticket plan generation rule start.log="  log);
     System.out.println("ENTER1. Ticket plan generation rule start.wfcontex="  wfcontex);
     System.out.println("ENTER1. Ticket plan generation rule start.workflow="  workflow);
     */
     ProvisioningPlan ticketPlan = null;

     if ( void == appName || null == appName ) {
        if (null != ticketManagementApplication)
            appName = ticketManagementApplication;
        else
            throw new Exception("appName was null, unable to build ticket plan.");
     }

     if ( void == action || null == action ) {
         Map wArgs = workflow.getVariables();
         action = wArgs.get("action");
         if ( null == action ){
            throw new Exception("Action was null, unable to build ticket plan.");
         }
     }

     if ( void == identityRequest || null == identityRequest ) {
         if ( null != identityRequestId ) {
             identityRequest = context.getObjectByName(IdentityRequest.class, identityRequestId);
             if (null == identityRequest){
                 throw new Exception("Identity request was null, unable to build ticket plan.");
             }
         }
         else {
             throw new Exception("identityRequestId was null, unable to build ticket plan.");
         }
     }

     if ( void == wfc || null == wfc ) {
        if ( null != wfcase ){
            wfc = wfcase;
        }
        else {
            throw new Exception("workflow context was null, unable to build ticket plan.");
        }
     }

     if ( Util.nullSafeEq(action, "open" ) || Util.nullSafeEq(action, "openNoApproval" ) ) {
          ticketPlan = buildOpenTicketPlan(action, identityRequest, appName);
     } else
     if ( Util.nullSafeEq(action, "postApproval" ) ) {
          ticketPlan = buildPostApprovalTicketPlan(action, identityRequest, appName);
     } else
     if ( Util.nullSafeEq(action, "postProvisioning" ) ) {
          ticketPlan = buildPostProvisioningTicketPlan(action, identityRequest, appName);
     } else
      if ( Util.nullSafeEq(action, "complete" ) ) {
          ticketPlan = buildCompleteProvisioningTicketPlan(action, identityRequest, appName);
     } else {
          throw new Exception("Unhandled action "+action+"' passed into ticket generation rule. Plan could not be generated");
     }
     /* System.out.println("EXIT1. Ticket plan generation rule end.\n" + ticketPlan.toXml()); */
     return ticketPlan;
    ]]>
  </Source>
</Rule>

<!--  Example Approval Assignment Rule  -->

<Rule language="beanshell" name="Example Approval Assignment Rule" 
      type="ApprovalAssignment">
      
  <Description>
     This example rule switches all of the owners to spadmin.  The idea 
     of this rule is to allow some customization of the approvals 
     so the ownership can be cacluated for cases where you might
     use and exteneded attribute or some other means outside our
     default mechanisms to derive the owner of the Approval.
     
     This rule is typically configured on the Approval Step
     in the LCM Provisioning Workflow or can be set on any
     steps based on the "Provisioning Approval" step 
     library.
     
     Since 6.2
  </Description>
  <Signature>
    <Inputs>
      <Argument name="log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="approvals">
        <Description>
          List of approvals generated by the approvalScheme, maybe null if there were no
          approvals enabled.
        </Description>
      </Argument>
      <Argument name="approvalSet">
        <Description>
          Representation of the cart, also found on the approvals generated by the 
          default schemes.
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='newApprovals'>
        <Description>
          
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    import sailpoint.object.Workflow;
    import sailpoint.object.Workflow.Approval;
    
    List newApprovals = null;
    if ( approvals != null ) {
        newApprovals = new ArrayList();
        for ( Approval approval : approvals ) {
            if ( approval != null ) {
                // update the approver/owner and the description of the approval
                approval.addArg(Workflow.ARG_WORK_ITEM_DESCRIPTION, "Approval Assignment Rule Generated" + identityName);
                approval.setOwner("spadmin");
                newApprovals.add(approval);
            }
        }
    }  
    return newApprovals;
  </Source>
</Rule>

<!--  Example customization Rule for peoplesoft hrms Direct connector  -->
<Rule language="beanshell" name="Example PeopleSoft HRMS Resource Object Customization Rule"
      type="ResourceObjectCustomization">
  <Description>
 This example checks for email, manager , first name, and last name in the resource object and then populate the values in return object.
  </Description>
  <Signature>
    <Inputs>
      <Argument name='context'>
        <Description>
           A SailPointContext object used if its necessary
           to query objects from the database.
        </Description>
      </Argument>
      <Argument name='object'>
        <Description>
          The ResourceObject built by the connector.
        </Description>
      </Argument>
      <Argument name='application'>
        <Description>
          Application that references the connector
        </Description>
      </Argument>
      <Argument name='connector'>
        <Description>
          The connector object
        </Description>
      </Argument>
    </Inputs>
    <Returns>
      <Argument name='A ResourceObject'>
        <Description>
          The updated resource object.
        </Description>
      </Argument>
    </Returns>
  </Signature>
  <Source>
    <![CDATA[
import java.util.*;
String jobRecData = null;
Map jobData = new HashMap();
Map collJob = new HashMap();
Object emailAttrib=object.getAttribute("COLL_EMAIL_ADDRESSES");
List email=null;
String emailId=null;
//code to populate email
if (null!=emailAttrib)
{
    if (emailAttrib instanceof List)
    {
        email=(List)emailAttrib;
        Object emailField=email.get(0);
        Map emailDetailMap=null;
        if (null!=emailField)
        {
 
            emailDetailMap=(Map)emailField;
            emailId=(String)emailDetailMap.get("PROP_EMAIL_ADDR");

        }
    }
}
   if (null!=emailId)
      object.put("EMAILID ", emailId);
//Code to populate manager,to set the status as active inactive, to populate the full name.
   Object collJobData = object.get("COLL_JOB");
   Map collJob=null;
   if (null != collJobData && collJobData instanceof List)
   {
     collJob = (Map) collJobData.get(0);
     String managerId = (String) collJob.get("PROP_SUPERVISOR_ID");
     String employeeHRStatus = (String) collJob.get("PROP_HR_STATUS");
     String employeeStatus=(String) collJob.get("PROP_EMPL_STATUS");
     if (null != managerId)
        object.put("MANAGER", managerId);
   
   if(null!=employeeHRStatus)
    {
      object.put("HR_STATUS", employeeHRStatus );
    }
   if(null!=employeeStatus)
   {
     object.put("EMPLOYEE_STATUS", employeeStatus);
if(employeeStatus.equals("A"))
object.put(openconnector.Connector.ATT_DISABLED, new Boolean(false));
else
object.put(openconnector.Connector.ATT_DISABLED, new Boolean(true));

   }
   }

//Fetching first name or last name
Object collNameTypeVw=object.get("COLL_NAME_TYPE_VW");
List collNames=null;
if(null!=collNameTypeVw && collNameTypeVw instanceof List)
{
 collNames=(List)collNameTypeVw;
Object collNamesObject=collNames.get(0);
Map collNamesMap=null;
if(null!=collNamesObject && collNamesObject instanceof Map)
{
collNamesMap=(Map)collNamesObject ;
if(null!=collNamesMap)
{
Object nameColl=collNamesMap.get("COLL_NAMES");
List nameCollList=null;
if(null!=nameColl && nameColl instanceof List){
nameCollList=(List)nameColl;
Object nameDetailsObject=null;
if(null!=nameCollList){

nameDetailsObject=nameCollList.get(0);
Map nameDetailsMap=null;
if(null!=nameDetailsObject && nameDetailsObject instanceof Map)
nameDetailsMap=(Map)nameDetailsObject;
if(null!=nameDetailsMap){
 String firstName=nameDetailsMap.get("PROP_FIRST_NAME");
String lastName=nameDetailsMap.get("PROP_LAST_NAME");
if(null!=firstName && null!=lastName)
{
 object.put("FULL_NAME",firstName +" "+lastName);
}
}
}
}
}
}
}

   return object;
    ]]>
  </Source>
</Rule>

  <!-- Example Account Selector rule. -->
  <Rule language="beanshell" name="Example Account Selector Rule"
        type="AccountSelector">
    <Description>
      AccountSelector Rules are used by the role modeler to automatically select a target account for provisioning when there are multiple candidates.

      The return value is a Link instance that represents the selection. Value can be:

      null - indicates that no automatic selection can be made

      "prompt" - indicates that a separate account selector should be presented for the role

      existing Link - the selected Link from the list of possible target Links

      a new Link instance - indicates that a new account must be created with the identity specified by the
      create policy, or manually; in this case, the Link instance returned will have a null nativeIdentity attribute

    </Description>
    <Signature returnType='Map'>
      <Inputs>
        <Argument name='source'>
          <Description>
            The application doing the provisioning.
          </Description>
        </Argument>
        <Argument name='assignedRole'>
          <Description>
            The assigned role being expanded.
          </Description>
        </Argument>
        <Argument name='role'>
          <Description>
            The IT role being provisioned that had the assignment rule.
          </Description>
        </Argument>
        <Argument name='identity'>
          <Description>
            The target identity.
          </Description>
        </Argument>
        <Argument name='application'>
          <Description>
            The target application object.
          </Description>
        </Argument>
        <Argument name='links'>
          <Description>
            A list of the possible target Links.
          </Description>
        </Argument>
        <Argument name="isSecondary">
          <Description>
            True if this is not the first assignment.
          </Description>
        </Argument>
        <Argument name="project">
          <Description>
            The provisioning project.
          </Description>
        </Argument>
        <Argument name="accountRequest">
          <Description>
            The account request.
          </Description>
        </Argument>
        <Argument name="allowCreate">
          <Description>
            True if account creation is allowed.
          </Description>
        </Argument>
      </Inputs>
      <Returns>
        <Argument name='selection'>
          <Description>
            A Link instance that represents the selection. Value can be:
            null - indicates that no automatic selection can be made
            Link - the selected Link from the list of possible target Links
            a new Link instance - indicates that a new account must be created with the identity specified by the
            create policy, or manually; in this case, the Link instance returned will have a null nativeIdentity attribute
          </Description>
        </Argument>
      </Returns>
    </Signature>
    <Source>
      <![CDATA[
      import sailpoint.object.Link;
      import sailpoint.object.Identity;
      import sailpoint.object.Bundle;
      import java.util.List;

      // For purposes of this example, we will pretend that any native identity which begins with the letter A
      // is an admin account, which is suitable for modifying. If we find more than one of these, or none, the rule is
      // unable to select a single account so we return null. If we find exactly one, we can return the Link object.
      Link selectedLink = null;
      if (links != null ) {
          for (Link link : links) {
              String id = link.getNativeIdentity();
              if (id.toLowerCase().startsWith("a")) {
                  if (selectedLink != null) {
                      // This is the second one we've found, so bail out, because we're unable to choose just one.
                      return null;
                  }
                  selectedLink = link;
              }
          }
      }

      // If selectedLink is non-null, it contains the chosen account information, otherwise we want to return null anyway
      // since we didn't find anything.
      // If we wanted this rule to indicate that the calling code should create a new account, we would create and
      // return a new Link instance with the nativeIdentity attribute set to null.
      return selectedLink;
      ]]>
    </Source>
  </Rule>

</sailpoint>
